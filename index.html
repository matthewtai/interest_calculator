<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Compound & Simple Interest Calculator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .scenario {
            margin-bottom: 40px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
        }
        
        .scenario h2 {
            background: #4CAF50;
            color: white;
            padding: 10px;
            margin: -20px -20px 20px -20px;
            border-radius: 6px 6px 0 0;
        }
        
        .input-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            align-items: end;
        }
        
        .input-group {
            display: grid;
            grid-template-rows: auto 1fr;
            align-items: end;
        }
        
        .input-group label {
            grid-row: 1;
            line-height: 1.3;
            margin-bottom: 8px;
            display: block;
        }
        
        .input-group input {
            grid-row: 2;
        }
        
        label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #555;
        }
        
        input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            margin-top: 0;
            box-sizing: border-box;
        }
        
        .input-group input {
            align-self: stretch;
        }
        
        button {
            background: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        .results {
            margin-top: 20px;
            background: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
            border-left: 4px solid #4CAF50;
        }
        
        .results-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin-top: 10px;
        }
        
        .results-table th,
        .results-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        
        .results-table th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        
        .results-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        .total-row {
            font-weight: bold;
            background-color: #e8f5e8 !important;
        }
        
        /* Tooltip styles */
        .tooltip-container {
            position: relative;
            display: inline-block;
            cursor: help;
        }
        
        .tooltip {
            visibility: hidden;
            width: 400px;
            background-color: #333;
            color: white;
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            margin-left: -200px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
            line-height: 1.4;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .tooltip::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }
        
        .tooltip-container:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }
        
        .calculation-step {
            margin: 5px 0;
            padding: 3px 0;
        }
        
        .calculation-formula {
            font-family: monospace;
            background-color: #444;
            padding: 2px 4px;
            border-radius: 3px;
            margin: 2px 0;
        }
        
        .tooltip-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            background-color: #007bff;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 16px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 5px;
            cursor: help;
            vertical-align: middle;
        }
        
        /* Drag and Drop Upload Styles */
        .upload-zone {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 40px 20px;
            text-align: center;
            background-color: #fafafa;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            margin-bottom: 15px;
        }
        
        .upload-zone:hover {
            border-color: #007bff;
            background-color: #f0f8ff;
        }
        
        .upload-zone.drag-over {
            border-color: #28a745;
            background-color: #f0fff0;
            transform: scale(1.02);
        }
        
        .upload-zone.drag-over .upload-icon {
            color: #28a745;
            animation: bounce 0.5s ease-in-out;
        }
        
        .upload-icon {
            font-size: 48px;
            color: #007bff;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }
        
        .upload-text {
            font-size: 16px;
            color: #555;
            margin-bottom: 10px;
            font-weight: 500;
        }
        
        .upload-subtext {
            font-size: 14px;
            color: #888;
            margin-bottom: 15px;
        }
        
        .upload-button {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,123,255,0.3);
        }
        
        .upload-button:hover {
            background: linear-gradient(135deg, #0056b3, #004085);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,123,255,0.4);
        }
        
        .file-info {
            display: none;
            margin-top: 15px;
            padding: 12px;
            background-color: #e8f5e8;
            border-radius: 6px;
            border-left: 4px solid #28a745;
        }
        
        .file-info.show {
            display: block;
            animation: slideIn 0.3s ease-out;
        }
        
        .file-name {
            font-weight: 500;
            color: #155724;
            margin-bottom: 5px;
        }
        
        .file-size {
            font-size: 12px;
            color: #6c757d;
        }
        
        .hidden-input {
            position: absolute;
            opacity: 0;
            pointer-events: none;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
        }
        
        @keyframes bounce {
            0%, 20%, 60%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            80% { transform: translateY(-5px); }
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .parse-section {
            display: none;
            margin-top: 15px;
        }
        
        .parse-section.show {
            display: block;
            animation: slideIn 0.3s ease-out;
        }
        
        /* Tab Navigation Styles */
        .tab-navigation {
            display: flex;
            background: #f8f9fa;
            border-radius: 8px 8px 0 0;
            margin: -30px -30px 30px -30px;
            border-bottom: 2px solid #e9ecef;
            overflow-x: auto;
            flex-wrap: nowrap;
        }
        
        .tab-button {
            background: none;
            border: none;
            padding: 15px 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #6c757d;
            transition: all 0.3s ease;
            white-space: nowrap;
            min-width: 140px;
            position: relative;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .tab-button:hover {
            background: #e9ecef;
            color: #495057;
        }
        
        .tab-button.active {
            background: white;
            color: #007bff;
            border-bottom: 3px solid #007bff;
            margin-bottom: -2px;
        }
        
        .tab-button.active::before {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 3px;
            background: #007bff;
            border-radius: 2px 2px 0 0;
        }
        
        .tab-icon {
            font-size: 16px;
        }
        
        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease-in-out;
        }
        
        .tab-content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Mobile responsive tabs */
        @media (max-width: 768px) {
            .tab-navigation {
                margin: -30px -20px 30px -20px;
            }
            
            .tab-button {
                min-width: 120px;
                padding: 12px 15px;
                font-size: 13px;
            }
        }
        
        /* Editable Results Table Styles */
        .editable-input {
            border: 1px solid transparent;
            background: transparent;
            padding: 4px 6px;
            border-radius: 3px;
            font-size: 14px;
            font-family: Arial, sans-serif;
            width: 100%;
            box-sizing: border-box;
            transition: all 0.2s ease;
        }
        
        .editable-input:hover {
            border-color: #007bff;
            background: #f8f9fa;
        }
        
        .editable-input:focus {
            outline: none;
            border-color: #007bff;
            background: white;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
        }
        
        .payment-row-modified {
            background-color: #fff3cd !important;
            border-left: 4px solid #ffc107;
        }
        
        .payment-row-modified .editable-input {
            background-color: #fffbf0;
            border-color: #ffc107;
        }
        
        .change-indicator {
            display: inline-block;
            margin-left: 5px;
            padding: 2px 6px;
            background-color: #ffc107;
            color: #856404;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            animation: pulse 1s ease-in-out;
        }
        
        .payment-changes-summary {
            margin-top: 15px;
            padding: 12px;
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            border-radius: 4px;
            display: none;
        }
        
        .payment-changes-summary.show {
            display: block;
            animation: slideIn 0.3s ease-out;
        }
        
        .change-list {
            margin-top: 8px;
            list-style: none;
            padding: 0;
        }
        
        .change-list li {
            margin: 4px 0;
            padding: 4px 0;
            font-size: 13px;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        /* Toast Notification Styles */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            padding: 12px 20px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            font-weight: 500;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
        }
        
        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }
        
        .toast.success {
            background: linear-gradient(135deg, #28a745, #20c997);
        }
        
        .toast.error {
            background: linear-gradient(135deg, #dc3545, #c82333);
        }
        
        .toast.warning {
            background: linear-gradient(135deg, #ffc107, #e0a800);
            color: #212529;
        }
        
        .toast-icon {
            font-size: 16px;
        }
        
        .toast-message {
            flex: 1;
        }
        
        @keyframes toastSlideIn {
            from { 
                opacity: 0; 
                transform: translateX(100%); 
            }
            to { 
                opacity: 1; 
                transform: translateX(0); 
            }
        }
        
        @keyframes toastSlideOut {
            from { 
                opacity: 1; 
                transform: translateX(0); 
            }
            to { 
                opacity: 0; 
                transform: translateX(100%); 
            }
        }
        
        /* Insert Row Functionality */
        .results-table tbody tr {
            position: relative;
        }
        
        .results-table tbody tr:hover .insert-add-btn {
            opacity: 1;
            visibility: visible;
        }
        
        .results-table tbody tr.custom-entry-row:hover .insert-delete-btn {
            opacity: 1;
            visibility: visible;
        }
        
        .insert-add-btn {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            color: #007bff;
            border: none;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            z-index: 10;
            line-height: 1;
            padding: 0;
            width: auto;
            height: auto;
        }
        
        .insert-add-btn:hover {
            color: #0056b3;
            transform: translateY(-50%) scale(1.2);
        }
        
        .insert-add-btn:active {
            transform: translateY(-50%) scale(1.1);
        }
        
        .insert-delete-btn {
            position: absolute;
            right: 30px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            color: #dc3545;
            border: none;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            z-index: 10;
            line-height: 1;
            padding: 0;
            width: auto;
            height: auto;
        }
        
        .insert-delete-btn:hover {
            color: #c82333;
            transform: translateY(-50%) scale(1.2);
        }
        
        .insert-delete-btn:active {
            transform: translateY(-50%) scale(1.1);
        }
        
        .insert-form-row {
            background: #f0f8ff !important;
            border: 2px solid #007bff;
        }
        
        .insert-form-row td {
            padding: 8px 4px !important;
        }
        
        .insert-form-input {
            width: 100%;
            padding: 4px 6px;
            border: 1px solid #007bff;
            border-radius: 3px;
            font-size: 14px;
            font-family: Arial, sans-serif;
            box-sizing: border-box;
        }
        
        .insert-form-select {
            width: 100%;
            padding: 4px 6px;
            border: 1px solid #007bff;
            border-radius: 3px;
            font-size: 14px;
            font-family: Arial, sans-serif;
            background: white;
        }
        
        .insert-form-buttons {
            display: flex;
            gap: 4px;
            justify-content: center;
        }
        
        .insert-btn {
            padding: 4px 8px;
            border: none;
            border-radius: 3px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .insert-btn-save {
            background: #28a745;
            color: white;
        }
        
        .insert-btn-save:hover {
            background: #218838;
        }
        
        .insert-btn-cancel {
            background: #6c757d;
            color: white;
        }
        
        .insert-btn-cancel:hover {
            background: #5a6268;
        }
        
        .custom-entry-row {
            background-color: #e8f4fd !important;
            border-left: 4px solid #007bff;
        }
        
        .custom-entry-indicator {
            display: inline-block;
            margin-left: 5px;
            padding: 2px 6px;
            background-color: #007bff;
            color: white;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>(Manage) Compound & Simple Interest Calculator</h1>
        
        <!-- Tab Navigation -->
        <div class="tab-navigation">
            <button class="tab-button active" onclick="switchTab('calculator')" id="tab-calculator">
                <span class="tab-icon">üßÆ</span>
                Calculator
            </button>
            <button class="tab-button" onclick="switchTab('payments')" id="tab-payments">
                <span class="tab-icon">üí∞</span>
                Payments & Credit Notes
            </button>
            <button class="tab-button" onclick="switchTab('upload')" id="tab-upload">
                <span class="tab-icon">üìÅ</span>
                (TE) CSV Upload
            </button>
            <button class="tab-button" onclick="switchTab('results')" id="tab-results">
                <span class="tab-icon">üìä</span>
                Results
            </button>
        </div>
        
        <!-- Tab Content Container -->
        <div class="scenario">
            <!-- Calculator Tab -->
            <div class="tab-content active" id="content-calculator">
                <h2>Interest Calculator</h2>
            <div style="margin-bottom: 20px; padding: 10px; background-color: #fffbe6; border-left: 4px solid #ffe066; border-radius: 4px;">
                <strong>Tip:</strong>
                To retrieve bill interest details via the API, use:<br>
                <code style="background: #f8f9fa; padding: 2px 6px; border-radius: 3px; font-size: 95%;">
                    https://app.clio.com/api/v4/bills/<span style="color:#007bff;">{bill_id}</span>?fields=interest{rate,period}
                </code><br><br>
                <small>Note: The rate is in decimal form, so 0.1 is 10%</small>
            </div>
            <!-- Interest Type Toggle -->
            <div style="margin-bottom: 20px; padding: 15px; background-color: #f0f8ff; border-radius: 5px;">
                <label style="font-weight: bold; margin-bottom: 10px; display: block;">Interest Type:</label>
                <div style="display: flex; gap: 20px;">
                    <label style="font-weight: normal; display: flex; align-items: center; gap: 5px;">
                        <input type="radio" name="interestType" value="compound" checked>
                        Compound Interest
                    </label>
                    <label style="font-weight: normal; display: flex; align-items: center; gap: 5px;">
                        <input type="radio" name="interestType" value="simple">
                        Simple Interest
                    </label>
                </div>
            </div>
            
            <div class="input-grid">
                <div class="input-group">
                    <label for="rate1">Annual Interest Rate (%):</label>
                    <input type="number" id="rate1" step="0.001" placeholder="5.0">
                </div>
                <div class="input-group">
                    <label for="issueDate1">Issue Date:</label>
                    <input type="date" id="issueDate1">
                </div>
                <div class="input-group">
                    <label for="dueDate1">Due Date:</label>
                    <input type="date" id="dueDate1">
                </div>
                <div class="input-group">
                    <label for="interval1">Interest Interval (days):</label>
                    <input type="number" id="interval1" placeholder="30">
                </div>
                <div class="input-group">
                    <label for="principal1">Starting Principal ($):</label>
                    <input type="number" id="principal1" step="0.01" placeholder="1000.00">
                </div>
            </div>
            </div>
            
            <!-- Payments Tab -->
            <div class="tab-content" id="content-payments">
                <h2>Payments & Credit Notes</h2>
                <div style="margin-bottom: 20px; padding: 10px; background-color: #e8f5e8; border-left: 4px solid #28a745; border-radius: 4px;">
                    <strong>Info:</strong>
                    Add any payments or credit notes that were applied to the bill. These will be factored into the interest calculations.
                </div>
                
                <div id="payments-container">
                    <!-- Payment rows will be added here -->
                </div>
                <button type="button" onclick="addPaymentRow()" style="background: #28a745; color: white; border: none; padding: 8px 15px; border-radius: 3px; cursor: pointer; margin-top: 10px;">Add Payment</button>
            </div>
            
            <!-- CSV Upload Tab -->
            <div class="tab-content" id="content-upload">
                <h2>(TE) CSV Upload</h2>
                <div style="margin-bottom: 20px; padding: 10px; background-color: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px;">
                    
                    Upload and parse a Bill Inspector CSV file to automatically populate the calculator with bill data including payments and credit notes
                </div>
                
                <!-- Drag and Drop Zone -->
                <div class="upload-zone" id="uploadZone">
                    <input type="file" id="csvFileInput" accept=".csv" class="hidden-input">
                    <div class="upload-icon">üìÅ</div>
                    <div class="upload-text">Drop your CSV file here</div>
                    <div class="upload-subtext">or click to browse files</div>
                    <button type="button" class="upload-button" onclick="document.getElementById('csvFileInput').click()">
                        Choose File
                    </button>
                </div>
                
                <!-- File Info Display -->
                <div class="file-info" id="fileInfo">
                    <div class="file-name" id="fileName"></div>
                    <div class="file-size" id="fileSize"></div>
                </div>
                
                <!-- Parse Section -->
                <div class="parse-section" id="parseSection">
                    <button onclick="uploadAndParseCSV()" class="upload-button" style="background: linear-gradient(135deg, #28a745, #20c997);">
                        Parse CSV Data
                    </button>
                </div>
                
                <div id="csvStatus" style="margin-top: 10px; padding: 10px; border-radius: 3px; display: none;"></div>
                <div id="csvPreview" style="margin-top: 10px; max-height: 200px; overflow-y: auto; background: white; padding: 10px; border: 1px solid #ddd; border-radius: 3px; display: none;"></div>
            </div>
            
            <!-- Results Tab -->
            <div class="tab-content" id="content-results">
                <h2>Interest Calculation Results</h2>
                <div id="results1" class="results" style="display:none;">
                    <div style="margin-bottom: 15px; padding: 10px; background-color: #f8f9fa; border-radius: 4px; border: 1px solid #dee2e6;">
                        <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                            <div>
                                <label for="periods1" style="font-weight: bold; margin-right: 10px;">Display Number of Interest Charges:</label>
                                <input type="number" id="periods1" min="1" value="5" style="width: 80px; padding: 5px; border: 1px solid #ccc; border-radius: 3px; margin-right: 10px;">
                                <button id="upToTodayBtn" onclick="calculatePeriodsToToday()" style="background: #17a2b8; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">Up to Today</button>
                            </div>
                            <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                                <button onclick="exportResultsToCSV()" style="background: #28a745; color: white; border: none; padding: 8px 15px; border-radius: 3px; cursor: pointer; font-size: 12px; display: flex; align-items: center; gap: 5px;">
                                    üìä Export CSV
                                </button>
                                <div style="display: flex; align-items: center; gap: 5px;">
                                    <input type="file" id="resultsDiscrepancyCsvInput" accept=".csv" style="display: none;">
                                    <button onclick="handleCompareButtonClick()" style="background: #007bff; color: white; border: none; padding: 8px 15px; border-radius: 3px; cursor: pointer; font-size: 12px; display: flex; align-items: center; gap: 5px;">
                                        üîç Compare Bill CSV
                                    </button>
                                    <button id="clearComparisonBtn" onclick="clearDiscrepancyAnalysis()" style="background: #6c757d; color: white; border: none; padding: 8px 15px; border-radius: 3px; cursor: pointer; font-size: 12px; display: none; align-items: center; gap: 5px;">
                                        ‚úñÔ∏è Clear Comparison
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="discrepancyStatus" style="margin: 10px 0; padding: 10px; border-radius: 3px; display: none;"></div>
                    <div id="results1-content"></div>
                </div>
            </div>
        </div>
        </div>
        
    </div>

    <script>
        let paymentCounter = 0;
        let originalPaymentData = new Map(); // Track original payment values
        let paymentModifications = new Map(); // Track modifications
        let customEntries = []; // Track custom entries added to results
        let currentInsertRowIndex = -1; // Track which row is currently being inserted
        let currentDiscrepancyData = null; // Store current discrepancy data for refreshes
        let hasUsedUpToToday = false; // Track if "Up to Today" button has been clicked
        
        // Refresh discrepancy analysis if it's currently active
        function refreshDiscrepancyAnalysis() {
            if (currentDiscrepancyData) {
                // Use the stored discrepancy data to refresh the analysis
                setTimeout(() => {
                    integrateDiscrepancyData(currentDiscrepancyData);
                }, 100); // Small delay to ensure calculations are complete
            }
        }
        
        function addPaymentRow() {
            paymentCounter++;
            const container = document.getElementById('payments-container');
            const paymentRow = document.createElement('div');
            paymentRow.id = `payment-row-${paymentCounter}`;
            paymentRow.style.cssText = 'display: flex; gap: 10px; margin-bottom: 10px; align-items: center;';
            
            paymentRow.innerHTML = `
                <div style="display: flex; flex-direction: column;">
                    <label style="font-size: 12px; margin-bottom: 2px;">Amount ($)</label>
                    <input type="number" id="payment-amount-${paymentCounter}" step="0.01" placeholder="0.00" style="width: 120px; padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
                </div>
                <div style="display: flex; flex-direction: column;">
                    <label style="font-size: 12px; margin-bottom: 2px;">Payment Date</label>
                    <input type="text" id="payment-date-${paymentCounter}" placeholder="MM/DD/YYYY" style="width: 140px; padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
                </div>
                <button type="button" onclick="removePaymentRow(${paymentCounter})" style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-top: 15px;">Remove</button>
            `;
            
            container.appendChild(paymentRow);
            
            // Add event listeners to the new payment inputs
            addPaymentEventListeners(paymentCounter);
        }
        
        function removePaymentRow(id) {
            const row = document.getElementById(`payment-row-${id}`);
            if (row) {
                row.remove();
                // Recalculate after removing payment
                calculateGracePeriod();
                
                // Refresh discrepancy analysis if active
                refreshDiscrepancyAnalysis();
            }
        }
        
        function getPayments() {
            const payments = [];
            const container = document.getElementById('payments-container');
            const paymentRows = container.children;
            
            for (let i = 0; i < paymentRows.length; i++) {
                const row = paymentRows[i];
                const id = row.id.split('-')[2];
                const amountInput = document.getElementById(`payment-amount-${id}`);
                const dateInput = document.getElementById(`payment-date-${id}`);
                
                if (amountInput && dateInput && amountInput.value && dateInput.value) {
                    const amount = parseFloat(amountInput.value);
                    let date;
                    let dateValid = false;
                    
                    // Try multiple date parsing strategies
                    const dateValue = dateInput.value.trim();
                    
                    // Strategy 1: MM/DD/YYYY format
                    if (dateValue.includes('/')) {
                        const parts = dateValue.split('/');
                        if (parts.length === 3) {
                            const month = parseInt(parts[0], 10);
                            const day = parseInt(parts[1], 10);
                            const year = parseInt(parts[2], 10);
                            
                            // Validate date components
                            if (month >= 1 && month <= 12 && day >= 1 && day <= 31 && year >= 1900 && year <= 2100) {
                                date = new Date(year, month - 1, day);
                                // Double-check the date is valid (handles invalid dates like 02/30/2023)
                                if (date.getFullYear() === year && date.getMonth() === (month - 1) && date.getDate() === day) {
                                    dateValid = true;
                                }
                            }
                        }
                    }
                    
                    // Strategy 2: Try standard Date parsing as fallback
                    if (!dateValid) {
                        try {
                            date = new Date(dateValue);
                            if (!isNaN(date.getTime()) && date.getFullYear() >= 1900 && date.getFullYear() <= 2100) {
                                dateValid = true;
                            }
                        } catch (e) {
                            // Ignore parsing errors
                        }
                    }
                    
                    // Strategy 3: If still invalid, use a default date but keep the payment
                    if (!dateValid) {
                        date = new Date(); // Use current date as fallback
                        dateValid = true;
                        
                        // Highlight the input field to show there's an issue
                        dateInput.style.border = '2px solid #dc3545';
                        dateInput.style.backgroundColor = '#f8d7da';
                        dateInput.title = `Invalid date format: "${dateValue}". Using current date for calculations.`;
                    } else {
                        // Clear any previous error styling
                        dateInput.style.border = '';
                        dateInput.style.backgroundColor = '';
                        dateInput.title = '';
                    }
                    
                    // Always include the payment if amount is valid, even with date issues
                    if (amount > 0 && !isNaN(amount)) {
                        payments.push({ 
                            amount, 
                            date, 
                            id,
                            originalDateValue: dateValue,
                            dateValid: dateValid
                        });
                    } else if (amountInput.value.trim() !== '') {
                        // Highlight invalid amounts too
                        console.warn(`Invalid amount for payment ${id}: "${amountInput.value}"`);
                        amountInput.style.border = '2px solid #dc3545';
                        amountInput.style.backgroundColor = '#f8d7da';
                        amountInput.title = `Invalid amount: "${amountInput.value}"`;
                    }
                } else if (amountInput && dateInput && (amountInput.value.trim() !== '' || dateInput.value.trim() !== '')) {
                    // Show warning for incomplete payments (has some data but not complete)
                    console.warn(`Incomplete payment data for payment ${id}: amount="${amountInput?.value}", date="${dateInput?.value}"`);
                    
                    if (!amountInput.value.trim()) {
                        amountInput.style.border = '2px solid #ffc107';
                        amountInput.style.backgroundColor = '#fff3cd';
                        amountInput.title = 'Amount is required';
                    }
                    if (!dateInput.value.trim()) {
                        dateInput.style.border = '2px solid #ffc107';
                        dateInput.style.backgroundColor = '#fff3cd';
                        dateInput.title = 'Date is required';
                    }
                }
            }
            
            // Sort payments by date, but handle invalid dates gracefully
            return payments.sort((a, b) => {
                try {
                    return a.date - b.date;
                } catch (e) {
                    console.warn('Error sorting payments by date:', e);
                    return 0; // Keep original order if sorting fails
                }
            });
        }

        // Tab Navigation functionality
        function switchTab(tabName) {
            // Hide all tab contents
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all tab buttons
            const tabButtons = document.querySelectorAll('.tab-button');
            tabButtons.forEach(button => {
                button.classList.remove('active');
            });
            
            // Show selected tab content
            const selectedContent = document.getElementById(`content-${tabName}`);
            if (selectedContent) {
                selectedContent.classList.add('active');
            }
            
            // Activate selected tab button
            const selectedButton = document.getElementById(`tab-${tabName}`);
            if (selectedButton) {
                selectedButton.classList.add('active');
            }
            
            // Restore comparison state when switching to Results tab
            if (tabName === 'results' && currentDiscrepancyData) {
                setTimeout(() => {
                    integrateDiscrepancyData(currentDiscrepancyData);
                }, 100);
            }
            
            // Auto-switch to results tab when calculations are completed
            if (tabName === 'calculator' || tabName === 'payments') {
                // Trigger recalculation to ensure results are up to date
                setTimeout(() => {
                    calculateGracePeriod();
                }, 100);
            }
        }
        
        // Auto-switch to results tab when results are available
        function autoSwitchToResults() {
            const resultsElement = document.getElementById('results1');
            if (resultsElement && resultsElement.style.display !== 'none') {
                // Only auto-switch if we're not already on the results tab
                const currentActiveTab = document.querySelector('.tab-button.active');
                if (currentActiveTab && currentActiveTab.id !== 'tab-results') {
                    // Add a visual indicator that results are ready
                    const resultsTab = document.getElementById('tab-results');
                    if (resultsTab) {
                        resultsTab.style.background = '#e8f5e8';
                        resultsTab.style.borderBottom = '3px solid #28a745';
                        
                        // Reset after a few seconds
                        setTimeout(() => {
                            if (!resultsTab.classList.contains('active')) {
                                resultsTab.style.background = '';
                                resultsTab.style.borderBottom = '';
                            }
                        }, 3000);
                    }
                }
            }
        }

        // Drag and Drop functionality
        function initializeDragAndDrop() {
            const uploadZone = document.getElementById('uploadZone');
            const fileInput = document.getElementById('csvFileInput');
            const fileInfo = document.getElementById('fileInfo');
            const parseSection = document.getElementById('parseSection');
            
            // Prevent default drag behaviors
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                uploadZone.addEventListener(eventName, preventDefaults, false);
                document.body.addEventListener(eventName, preventDefaults, false);
            });
            
            // Highlight drop area when item is dragged over it
            ['dragenter', 'dragover'].forEach(eventName => {
                uploadZone.addEventListener(eventName, highlight, false);
            });
            
            ['dragleave', 'drop'].forEach(eventName => {
                uploadZone.addEventListener(eventName, unhighlight, false);
            });
            
            // Handle dropped files
            uploadZone.addEventListener('drop', handleDrop, false);
            
            // Handle file input change
            fileInput.addEventListener('change', handleFileSelect, false);
            
            // Make upload zone clickable
            uploadZone.addEventListener('click', function(e) {
                if (e.target.tagName !== 'BUTTON') {
                    fileInput.click();
                }
            });
            
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            function highlight(e) {
                uploadZone.classList.add('drag-over');
            }
            
            function unhighlight(e) {
                uploadZone.classList.remove('drag-over');
            }
            
            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                
                if (files.length > 0) {
                    const file = files[0];
                    if (file.type === 'text/csv' || file.name.toLowerCase().endsWith('.csv')) {
                        fileInput.files = files;
                        handleFileSelect({ target: { files: files } });
                    } else {
                        showCSVStatus('Please upload a CSV file only.', 'error');
                    }
                }
            }
            
            function handleFileSelect(e) {
                const files = e.target.files;
                if (files.length > 0) {
                    const file = files[0];
                    displayFileInfo(file);
                }
            }
            
            function displayFileInfo(file) {
                const fileName = document.getElementById('fileName');
                const fileSize = document.getElementById('fileSize');
                
                fileName.textContent = `üìÑ ${file.name}`;
                fileSize.textContent = `Size: ${formatFileSize(file.size)}`;
                
                fileInfo.classList.add('show');
                parseSection.classList.add('show');
                
                // Update upload zone appearance
                const uploadIcon = uploadZone.querySelector('.upload-icon');
                const uploadText = uploadZone.querySelector('.upload-text');
                const uploadSubtext = uploadZone.querySelector('.upload-subtext');
                const uploadButton = uploadZone.querySelector('.upload-button');
                
                uploadIcon.textContent = '‚úÖ';
                uploadIcon.style.color = '#28a745';
                uploadText.textContent = 'File selected successfully!';
                uploadSubtext.textContent = 'Click "Parse CSV Data" below to process the file';
                uploadButton.style.display = 'none';
            }
            
            function formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
        }

        // CSV Upload and Parsing Functions
        function uploadAndParseCSV() {
            const fileInput = document.getElementById('csvFileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                showCSVStatus('Please select a CSV file first.', 'error');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csvContent = e.target.result;
                    const parsedData = parseCSVContent(csvContent);
                    
                    if (parsedData) {
                        populateCalculatorFromCSV(parsedData);
                        showCSVStatus('CSV data successfully parsed and applied!', 'success');
                        showCSVPreview(parsedData);
                    } else {
                        showCSVStatus('Failed to parse CSV data. Please check the file format.', 'error');
                    }
                } catch (error) {
                    showCSVStatus('Error reading CSV file: ' + error.message, 'error');
                }
            };
            
            reader.readAsText(file);
        }
        
        function parseCSVContent(csvContent) {
            // Remove BOM if present - handle multiple BOM types comprehensively
            // UTF-8 BOM (0xFEFF as single character)
            if (csvContent.charCodeAt(0) === 0xFEFF) {
                csvContent = csvContent.substring(1);
            }
            // UTF-8 BOM as Unicode replacement character
            else if (csvContent.startsWith('\uFEFF')) {
                csvContent = csvContent.substring(1);
            }
            // UTF-8 BOM as raw bytes (EF BB BF) - sometimes appears as these characters
            else if (csvContent.startsWith('Ôªø')) {
                csvContent = csvContent.substring(1);
            }
            // UTF-16 BE BOM (0xFFFE)
            else if (csvContent.charCodeAt(0) === 0xFFFE) {
                csvContent = csvContent.substring(1);
            }
            
            const lines = csvContent.split('\n').map(line => line.trim()).filter(line => line);
            
            try {
                // Find the main bill data (line 3 in the provided example)
                const billDataLine = lines[2]; // 0-indexed, so line 3 is index 2
                const billData = parseCSVLine(billDataLine);
                
                // Extract bill information
                const billInfo = {
                    balance: parseFloat(billData[54]) || 0, // Use 'total' column (index 54, not 55)
                    interestRate: parseFloat(billData[22]) || 0, // interest_rate column
                    interestPeriod: parseInt(billData[21]) || 30, // interest_period column
                    issuedAt: billData[24] || '', // issued_at column
                    dueAt: billData[16] || '', // due_at column
                    compoundInterest: (billData[44] && (billData[44].toLowerCase() === 'true' || billData[44] === '1')), // compound_interest? column - handle different true formats
                    payments: [],
                    creditNotes: []
                };
                
                // Find and parse Asset Transactions (payments)
                const assetTransactionStart = findSectionStart(lines, 'Asset transactions');
                if (assetTransactionStart > 0) {
                    // Parse all asset transaction lines
                    for (let i = assetTransactionStart + 2; i < lines.length; i++) {
                        const line = lines[i];
                        if (!line || line.trim() === '' || line.toLowerCase().includes('credit notes')) {
                            break; // End of asset transactions section
                        }
                        
                        const assetData = parseCSVLine(line);
                        if (assetData[1] && assetData[11] && parseFloat(assetData[1]) > 0) { // amount and date
                            billInfo.payments.push({
                                amount: parseFloat(assetData[1]),
                                date: assetData[11]
                            });
                        }
                    }
                }
                
                // Find and parse Credit Notes
                const creditNoteStart = findSectionStart(lines, 'Credit notes');
                if (creditNoteStart > 0) {
                    // Parse all credit note lines
                    for (let i = creditNoteStart + 2; i < lines.length; i++) {
                        const line = lines[i];
                        if (!line || line.trim() === '') {
                            break; // End of credit notes section
                        }
                        
                        const creditData = parseCSVLine(line);
                        if (creditData[1] && creditData[5] && parseFloat(creditData[1]) > 0) { // amount and date
                            billInfo.payments.push({
                                amount: parseFloat(creditData[1]),
                                date: creditData[5]
                            });
                        }
                    }
                }
                
                return billInfo;
            } catch (error) {
                console.error('Error parsing CSV:', error);
                return null;
            }
        }
        
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            
            result.push(current.trim());
            return result;
        }
        
        function findSectionStart(lines, sectionName) {
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].toLowerCase().includes(sectionName.toLowerCase())) {
                    return i;
                }
            }
            return -1;
        }
        
        function populateCalculatorFromCSV(data) {
            // Set basic bill information
            document.getElementById('rate1').value = (data.interestRate * 100).toFixed(3); // Convert to percentage
            document.getElementById('interval1').value = data.interestPeriod;
            document.getElementById('principal1').value = data.balance.toFixed(2);
            
            // Set dates (convert from M/D/YYYY to YYYY-MM-DD format)
            if (data.issuedAt) {
                const issueDate = convertDateFormat(data.issuedAt);
                if (issueDate) document.getElementById('issueDate1').value = issueDate;
            }
            
            if (data.dueAt) {
                const dueDate = convertDateFormat(data.dueAt);
                if (dueDate) document.getElementById('dueDate1').value = dueDate;
            }
            
            // Set interest type
            const compoundRadio = document.querySelector('input[name="interestType"][value="compound"]');
            const simpleRadio = document.querySelector('input[name="interestType"][value="simple"]');
            
            if (data.compoundInterest) {
                compoundRadio.checked = true;
                simpleRadio.checked = false;
            } else {
                simpleRadio.checked = true;
                compoundRadio.checked = false;
            }
            
            // Clear existing payments
            const paymentsContainer = document.getElementById('payments-container');
            paymentsContainer.innerHTML = '';
            
            // Add payments from CSV
            data.payments.forEach(payment => {
                addPaymentFromCSV(payment.amount, payment.date);
            });
            
            // Trigger recalculation first
            calculateGracePeriod();
            
            // Auto-click "Up to Today" to prepare for comparison
            calculatePeriodsToToday();
            
            // Extract interest data from the same CSV for comparison
            const csvFileInput = document.getElementById('csvFileInput');
            if (csvFileInput && csvFileInput.files[0]) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const csvText = e.target.result;
                        const interestData = parseDiscrepancyCSVData(csvText);
                        
                        if (interestData && interestData.length > 0) {
                            // Store the interest data and integrate it
                            currentDiscrepancyData = interestData;
                            
                            // Small delay to ensure calculations are complete
                            setTimeout(() => {
                                integrateDiscrepancyData(interestData);
                                showDiscrepancyStatus(`‚úÖ Bill Inspector CSV loaded with ${interestData.length} interest charges for comparison`, 'success');
                            }, 200);
                        }
                    } catch (error) {
                        console.log('Could not extract interest data for comparison:', error.message);
                    }
                };
                reader.readAsText(csvFileInput.files[0]);
            }
            
            // Switch to results tab to show the calculations
            switchTab('results');
        }
        
        function convertDateFormat(dateStr) {
            // Convert M/D/YYYY to YYYY-MM-DD
            const parts = dateStr.split('/');
            if (parts.length === 3) {
                const month = parts[0].padStart(2, '0');
                const day = parts[1].padStart(2, '0');
                const year = parts[2];
                return `${year}-${month}-${day}`;
            }
            return null;
        }
        
        function addPaymentFromCSV(amount, date) {
            paymentCounter++;
            const container = document.getElementById('payments-container');
            const paymentRow = document.createElement('div');
            paymentRow.id = `payment-row-${paymentCounter}`;
            paymentRow.style.cssText = 'display: flex; gap: 10px; margin-bottom: 10px; align-items: center;';
            
            const convertedDate = convertDateFormat(date);
            
            paymentRow.innerHTML = `
                <div style="display: flex; flex-direction: column;">
                    <label style="font-size: 12px; margin-bottom: 2px;">Amount ($)</label>
                    <input type="number" id="payment-amount-${paymentCounter}" step="0.01" value="${amount}" style="width: 120px; padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
                </div>
                <div style="display: flex; flex-direction: column;">
                    <label style="font-size: 12px; margin-bottom: 2px;">Payment Date</label>
                    <input type="text" id="payment-date-${paymentCounter}" value="${date}" placeholder="MM/DD/YYYY" style="width: 140px; padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
                </div>
                <button type="button" onclick="removePaymentRow(${paymentCounter})" style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-top: 15px;">
            `;
            
            container.appendChild(paymentRow);
            addPaymentEventListeners(paymentCounter);
        }
        
        function showCSVStatus(message, type) {
            const statusDiv = document.getElementById('csvStatus');
            statusDiv.style.display = 'block';
            statusDiv.textContent = message;
            
            if (type === 'success') {
                statusDiv.style.backgroundColor = '#d4edda';
                statusDiv.style.color = '#155724';
                statusDiv.style.border = '1px solid #c3e6cb';
            } else if (type === 'error') {
                statusDiv.style.backgroundColor = '#f8d7da';
                statusDiv.style.color = '#721c24';
                statusDiv.style.border = '1px solid #f5c6cb';
            }
        }
        
        function showCSVPreview(data) {
            const previewDiv = document.getElementById('csvPreview');
            previewDiv.style.display = 'block';
            
            let html = '<h4>Parsed Data Preview:</h4>';
            html += `<p><strong>Starting Principal (Total):</strong> $${data.balance.toFixed(2)}</p>`;
            html += `<p><strong>Interest Rate:</strong> ${(data.interestRate * 100).toFixed(3)}%</p>`;
            html += `<p><strong>Interest Period:</strong> ${data.interestPeriod} days</p>`;
            html += `<p><strong>Issue Date:</strong> ${data.issuedAt}</p>`;
            html += `<p><strong>Due Date:</strong> ${data.dueAt}</p>`;
            html += `<p><strong>Interest Type:</strong> ${data.compoundInterest ? 'Compound' : 'Simple'}</p>`;
            
            if (data.payments.length > 0) {
                html += '<p><strong>Payments/Credits:</strong></p><ul>';
                data.payments.forEach(payment => {
                    html += `<li>$${payment.amount.toFixed(2)} on ${payment.date}</li>`;
                });
                html += '</ul>';
            } else {
                html += '<p><strong>Payments/Credits:</strong> None found</p>';
            }
            
            previewDiv.innerHTML = html;
        }

            function calculatePeriodsToToday() {
                const issueDateStr = document.getElementById('issueDate1').value;
                const interval = parseInt(document.getElementById('interval1').value);
                const gracePeriodDays = calculateDaysBetween(
                    new Date(issueDateStr + 'T00:00:00'),
                    new Date(document.getElementById('dueDate1').value + 'T00:00:00')
                );
                
                if (!issueDateStr || !interval || interval <= 0) {
                    alert('Please enter valid issue date and interest interval first.');
                    return;
                }
                
                const issueDate = new Date(issueDateStr + 'T00:00:00');
                const today = new Date();
                
                // Calculate first interest date
                let firstInterestDate;
                if (gracePeriodDays === 0) {
                    firstInterestDate = addDays(issueDate, interval + 1);
                } else {
                    const dueDate = new Date(document.getElementById('dueDate1').value + 'T00:00:00');
                    firstInterestDate = addDays(dueDate, 1);
                }
                
                // Calculate how many periods we need to reach today
                if (today <= firstInterestDate) {
                    // Today is before the first interest charge
                    document.getElementById('periods1').value = 1;
                } else {
                    // Calculate number of periods from first interest date to today
                    const daysSinceFirst = calculateDaysBetween(firstInterestDate, today);
                    const additionalPeriods = Math.floor(daysSinceFirst / interval);
                    const totalPeriods = 1 + additionalPeriods;
                    document.getElementById('periods1').value = totalPeriods;
                }
                
                // Trigger recalculation with flag to indicate this is from "Up to Today"
                calculateGracePeriod(true);
                
                // Set flag to indicate "Up to Today" has been used
                hasUsedUpToToday = true;
            }

            function calculateGracePeriod(fromUpToToday = false) {
            // Reset the "Up to Today" flag when calculations change (unless called from "Up to Today")
            if (!fromUpToToday) {
                hasUsedUpToToday = false;
            }
            
            const rate = parseFloat(document.getElementById('rate1').value) / 100;
            const issueDateStr = document.getElementById('issueDate1').value;
            const dueDateStr = document.getElementById('dueDate1').value;
            const issueDate = new Date(issueDateStr + 'T00:00:00');
            const dueDate = new Date(dueDateStr + 'T00:00:00');
            const interval = parseInt(document.getElementById('interval1').value);
            const principal = parseFloat(document.getElementById('principal1').value);
            const periods = parseInt(document.getElementById('periods1').value);
            const interestType = document.querySelector('input[name="interestType"]:checked').value;
            const payments = getPayments();
            
            // Check for required fields more carefully
            if (!rate || rate <= 0 || !principal || principal <= 0 || !interval || interval <= 0 || !issueDateStr || !dueDateStr || !periods || periods < 1) {
                // Hide results if required fields are not filled
                document.getElementById('results1').style.display = 'none';
                return;
            }
            
            // Check if dates are valid
            if (isNaN(issueDate.getTime()) || isNaN(dueDate.getTime())) {
                document.getElementById('results1').style.display = 'none';
                return;
            }
            
            const daysBetween = Math.ceil((dueDate - issueDate) / (1000 * 60 * 60 * 24));
            
            let results = [];
            let runningTotal = principal;
            let originalPrincipal = principal;
            let currentPrincipal = principal; // For simple interest, this gets reduced by payments
            
            // Create timeline of events (interest charges and payments)
            let timeline = [];
            
            // Add first interest charge
            const gracePeriodDays = calculateDaysBetween(issueDate, dueDate);
            let firstInterestDate;
            
            if (gracePeriodDays === 0) {
                // No grace period: first interest occurs after the first interval
                firstInterestDate = addDays(issueDate, interval + 1);
            } else {
                // Grace period exists: first interest occurs one day after due date
                firstInterestDate = addDays(dueDate, 1);
            }
            
            timeline.push({
                type: 'interest',
                date: firstInterestDate,
                period: 1,
                periodName: '1st Interest'
            });
            
            // Add subsequent interest charges
            let currentDate = new Date(firstInterestDate);
            for (let i = 2; i <= periods; i++) {
                currentDate = addDays(currentDate, interval);
                timeline.push({
                    type: 'interest',
                    date: new Date(currentDate),
                    period: i,
                    periodName: `${getOrdinal(i)} Interest`
                });
            }
            
            // Add payments to timeline
            payments.forEach(payment => {
                timeline.push({
                    type: 'payment',
                    date: payment.date,
                    amount: payment.amount,
                    id: payment.id
                });
            });
            
            // Add custom entries to timeline
            customEntries.forEach(entry => {
                timeline.push({
                    type: 'custom',
                    subType: entry.subType,
                    date: entry.date,
                    amount: entry.amount,
                    description: entry.description,
                    id: entry.id
                });
            });
            
            // Sort timeline by date
            timeline.sort((a, b) => a.date - b.date);
            
            // Process timeline events
            let lastEventDate = issueDate;
            
            timeline.forEach(event => {
                if (event.type === 'interest') {
                    // Calculate interest for this period
                    let accrualStartDate, accrualDays;
                    
                    if (event.period === 1) {
                        // First interest: check if there's a grace period
                        accrualStartDate = issueDate;
                        const gracePeriodDays = calculateDaysBetween(issueDate, dueDate);
                        
                        if (gracePeriodDays === 0) {
                            // No grace period: interest accrues for the interval period + 1 day
                            accrualDays = interval + 1;
                        } else {
                            // Grace period exists: first interest accrues from issue date to due date
                            accrualDays = gracePeriodDays;
                        }
                    } else {
                        // Subsequent interests: accrue from last event
                        accrualStartDate = lastEventDate;
                        accrualDays = interval;
                    }
                    
                    let interestAmount;
                    let calculationDetails;
                    let principalUsed = (interestType === 'simple') ? currentPrincipal : runningTotal;
                    
                    // Calculate interest and round to 2 decimal places
                    const rawInterest = principalUsed * rate * (accrualDays / 365);
                    interestAmount = Math.round(rawInterest * 100) / 100;
                    
                    calculationDetails = {
                        type: interestType === 'simple' ? 'Simple Interest' : 'Compound Interest',
                        principalUsed: principalUsed,
                        rate: rate,
                        days: accrualDays,
                        totalDays: 365,
                        formula: `$${principalUsed.toFixed(2)} √ó ${(rate * 100).toFixed(3)}% √ó (${accrualDays}/365)`,
                        calculation: `$${principalUsed.toFixed(2)} √ó ${rate.toFixed(6)} √ó ${(accrualDays/365).toFixed(6)}`,
                        result: interestAmount,
                        explanation: event.period === 1 ? 
                            `${gracePeriodDays === 0 
                                ? `No grace period: First interest charge appears ${accrualDays} days after issue date (day of invoice + interest interval). Interest covers the full ${accrualDays}-day period from issue date to charge date.` 
                                : `With Grace period: Interest accrues from issue date to due date (${gracePeriodDays} days). First charge appears one day after the due date. Interest covers the ${accrualDays}-day grace period.`} ${interestType === 'simple' ? 'Simple interest uses the current principal' : 'Compound interest uses the current balance'} of $${principalUsed.toFixed(2)}.` :
                            `Subsequent interest charge: This is the ${event.periodName.toLowerCase()} period covering ${accrualDays} days based on the ${interval}-day interest interval. ${interestType === 'simple' ? 'Simple interest uses the current principal' : 'Compound interest uses the current balance'} of $${principalUsed.toFixed(2)}${interestType === 'compound' ? ', which includes all previous interest' : ', which may have been reduced by payments'}.`
                    };
                
                results.push({
                        type: 'interest',
                        period: event.periodName,
                        date: formatDate(event.date),
                        days: accrualDays,
                    interest: interestAmount,
                        balance: runningTotal + interestAmount,
                        calculationDetails: calculationDetails
                });
                
                runningTotal += interestAmount;
                    
                } else if (event.type === 'payment') {
                    // Apply payment
                    const paymentAmount = Math.min(event.amount, runningTotal); // Can't pay more than owed
                    runningTotal -= paymentAmount;
                    
                    // For simple interest, reduce the principal used for future calculations
                    if (interestType === 'simple') {
                        currentPrincipal = Math.max(0, currentPrincipal - paymentAmount);
                    }
                    
                    results.push({
                        type: 'payment',
                        period: 'Payment',
                        date: formatDate(event.date),
                        rawDate: event.date,
                        days: '-',
                        interest: 0,
                        payment: paymentAmount,
                        originalAmount: event.amount,
                        originalDate: formatDate(event.date),
                        balance: runningTotal,
                        id: event.id,
                        calculationDetails: {
                            type: 'Payment Applied',
                            explanation: `Payment of $${event.amount.toFixed(2)} applied. ${paymentAmount < event.amount ? `Only $${paymentAmount.toFixed(2)} was applied as it cannot exceed the current balance.` : ''} ${interestType === 'simple' ? `For simple interest, this reduces the principal used for future interest calculations to $${currentPrincipal.toFixed(2)}.` : ''}`,
                            result: paymentAmount
                        }
                    });
                } else if (event.type === 'custom') {
                    // Apply custom entry
                    const customAmount = event.amount;
                    runningTotal += customAmount; // Positive amounts increase balance, negative decrease
                    
                    // For simple interest and negative amounts (payments/credits), reduce principal
                    if (interestType === 'simple' && customAmount < 0) {
                        currentPrincipal = Math.max(0, currentPrincipal + customAmount); // customAmount is negative
                    }
                    
                    results.push({
                        type: 'custom',
                        subType: event.subType,
                        period: event.description,
                        date: formatDate(event.date),
                        rawDate: event.date,
                        days: '-',
                        interest: 0,
                        customAmount: customAmount,
                        balance: runningTotal,
                        id: event.id,
                        calculationDetails: {
                            type: event.description,
                            explanation: `Custom entry: ${event.description} of ${customAmount >= 0 ? '+' : ''}$${customAmount.toFixed(2)} applied. ${interestType === 'simple' && customAmount < 0 ? `For simple interest, this reduces the principal used for future interest calculations to $${currentPrincipal.toFixed(2)}.` : ''}`,
                            result: Math.abs(customAmount)
                        }
                    });
                }
                
                lastEventDate = new Date(event.date);
            });
            
            displayResults('results1-content', results, daysBetween, originalPrincipal, interestType);
        }
        
        
        function displayResults(elementId, results, daysBetween, principal, interestType) {
            let html = '';
            
            if (daysBetween > 0) {
                html += `<p><strong>Days between Issue and Due Date:</strong> ${daysBetween}</p>`;
            }
            
            if (interestType) {
                html += `<p><strong>Interest Type:</strong> ${interestType.charAt(0).toUpperCase() + interestType.slice(1)} Interest</p>`;
            }
            
            html += `
                <table class="results-table">
                    <thead>
                        <tr>
                            <th>Period</th>
                            <th>Date</th>
                            <th>Days</th>
                            <th>Interest <span class="tooltip-icon" title="Hover over interest amounts to see detailed calculations">?</span></th>
                            <th id="actualColumn" style="display: none;">Actual</th>
                            <th>Running Balance</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            let totalInterest = 0;
            let finalBalance = principal; // Start with original principal
            
            results.forEach(result => {
                if (result.type === 'interest') {
                totalInterest += result.interest;
                    
                    // Create tooltip content for interest
                    const details = result.calculationDetails;
                    const tooltipContent = `
                        <div class="calculation-step"><strong>${details.type} Calculation</strong></div>
                        <div class="calculation-step">${details.explanation}</div>
                        <div class="calculation-step">
                            <strong>Formula:</strong><br>
                            <div class="calculation-formula">Principal √ó Rate √ó (Days √∑ 365)</div>
                        </div>
                        <div class="calculation-step">
                            <strong>Substitution:</strong><br>
                            <div class="calculation-formula">${details.formula}</div>
                        </div>
                        <div class="calculation-step">
                            <strong>Calculation:</strong><br>
                            <div class="calculation-formula">${details.calculation} = $${details.result.toFixed(2)}</div>
                        </div>
                        <div class="calculation-step">
                            <strong>Rate Details:</strong><br>
                            Annual rate: ${(details.rate * 100).toFixed(3)}%<br>
                            Period: ${details.days} days out of ${details.totalDays} days
                        </div>
                    `;
                    
                html += `
                    <tr data-row-index="${results.indexOf(result)}" style="position: relative;">
                        <td>${result.period}</td>
                        <td>${result.date}</td>
                        <td>${result.days}</td>
                            <td>
                                <div class="tooltip-container">
                                    $${result.interest.toFixed(2)}
                                    <div class="tooltip">${tooltipContent}</div>
                                </div>
                            </td>
                            <td class="actual-column" style="display: none;" data-date="${result.date}">
                                <span class="actual-amount">-</span>
                                <span class="comparison-indicator" style="margin-left: 5px;"></span>
                            </td>
                            <td style="position: relative;">
                                $${result.balance.toFixed(2)}
                                <button class="insert-add-btn" onclick="showInsertForm(${results.indexOf(result)})" title="Add entry after this row">+</button>
                            </td>
                        </tr>
                    `;
                } else if (result.type === 'payment') {
                    // Create tooltip content for payment
                    const details = result.calculationDetails;
                    const tooltipContent = `
                        <div class="calculation-step"><strong>${details.type}</strong></div>
                        <div class="calculation-step">${details.explanation}</div>
                        <div class="calculation-step">
                            <strong>Payment Amount:</strong> $${details.result.toFixed(2)}
                        </div>
                    `;
                    
                    // Store original payment data if not already stored
                    const paymentKey = `payment-${result.id}`;
                    if (!originalPaymentData.has(paymentKey)) {
                        originalPaymentData.set(paymentKey, {
                            amount: result.payment,
                            date: result.date,
                            originalAmount: result.originalAmount || result.payment,
                            originalDate: result.originalDate || result.date
                        });
                    }
                    
                    const isModified = paymentModifications.has(paymentKey);
                    const modificationClass = isModified ? 'payment-row-modified' : '';
                    const changeIndicator = isModified ? '<span class="change-indicator">MODIFIED</span>' : '';
                    
                    // Check if this payment date was modified
                    const modification = paymentModifications.get(paymentKey);
                    const hasDateModification = modification && modification.date;
                    
                    let dateDisplayHtml;
                    if (hasDateModification) {
                        // Show both original and modified dates
                        dateDisplayHtml = `
                            <div style="margin-bottom: 5px;">
                                <input type="text" 
                                       class="editable-input payment-date-edit" 
                                       value="${formatDate(modification.date)}"
                                       placeholder="MM/DD/YYYY"
                                       data-payment-key="${paymentKey}"
                                       onchange="updatePaymentFromTable('${paymentKey}', 'date', this.value)">
                            </div>
                            <div style="font-size: 11px; color: #6c757d; font-style: italic;">
                                Original: ${modification.originalDate}
                            </div>
                        `;
                    } else {
                        // Show just the editable date input
                        dateDisplayHtml = `
                            <input type="text" 
                                   class="editable-input payment-date-edit" 
                                   value="${result.date}"
                                   placeholder="MM/DD/YYYY"
                                   data-payment-key="${paymentKey}"
                                   onchange="updatePaymentFromTable('${paymentKey}', 'date', this.value)">
                        `;
                    }
                    
                    html += `
                        <tr class="${modificationClass}" data-payment-key="${paymentKey}" data-row-index="${results.indexOf(result)}" style="position: relative; ${!isModified ? 'background-color: #e8f5e8;' : ''}">
                            <td>${result.period}${changeIndicator}</td>
                            <td>${dateDisplayHtml}</td>
                            <td>${result.days}</td>
                            <td>
                                <div class="tooltip-container">
                                    -$${result.payment.toFixed(2)}
                                    <div class="tooltip">${tooltipContent}</div>
                                </div>
                            </td>
                            <td class="actual-column" style="display: none;">-</td>
                            <td style="position: relative;">
                                $${result.balance.toFixed(2)}
                                <button class="insert-add-btn" onclick="showInsertForm(${results.indexOf(result)})" title="Add entry after this row">+</button>
                            </td>
                        </tr>
                    `;
                } else if (result.type === 'custom') {
                    // Create tooltip content for custom entry
                    const details = result.calculationDetails;
                    const tooltipContent = `
                        <div class="calculation-step"><strong>${details.type}</strong></div>
                        <div class="calculation-step">${details.explanation}</div>
                        <div class="calculation-step">
                            <strong>Amount:</strong> ${result.customAmount >= 0 ? '+' : ''}$${Math.abs(result.customAmount).toFixed(2)}
                        </div>
                    `;
                    
                    const amountDisplay = result.customAmount >= 0 ? 
                        `+$${result.customAmount.toFixed(2)}` : 
                        `-$${Math.abs(result.customAmount).toFixed(2)}`;
                    
                    // Custom entries don't need modification tracking since they're user-created
                    const customKey = `custom-${result.id}`;
                    const customModificationClass = '';
                    const customChangeIndicator = '';
                    
                    // No need to store original data for custom entries since we don't track modifications
                    
                    let customDescriptionHtml, customDateHtml, customAmountHtml;
                    
                    // Description field - always editable without modification tracking
                    customDescriptionHtml = `
                        <input type="text" 
                               class="editable-input custom-description-edit" 
                               value="${result.period}"
                               data-custom-key="${customKey}"
                               onchange="updateCustomEntryFromTable('${customKey}', 'description', this.value)"
                               style="width: 100%;">
                    `;
                    
                    // Date field - always editable without modification tracking
                    customDateHtml = `
                        <input type="text" 
                               class="editable-input custom-date-edit" 
                               value="${result.date}"
                               placeholder="MM/DD/YYYY"
                               data-custom-key="${customKey}"
                               onchange="updateCustomEntryFromTable('${customKey}', 'date', this.value)">
                    `;
                    
                    // Amount field - always editable without modification tracking
                    customAmountHtml = `
                        <input type="number" 
                               class="editable-input custom-amount-edit" 
                               value="${result.customAmount.toFixed(2)}"
                               step="0.01"
                               data-custom-key="${customKey}"
                               onchange="updateCustomEntryFromTable('${customKey}', 'amount', this.value)"
                               style="width: 80px; display: inline-block;">
                    `;
                    
                    html += `
                        <tr class="custom-entry-row ${customModificationClass}" data-row-index="${results.indexOf(result)}" data-custom-key="${customKey}" style="position: relative;">
                            <td>${customDescriptionHtml}<span class="custom-entry-indicator">CUSTOM</span>${customChangeIndicator}</td>
                            <td>${customDateHtml}</td>
                            <td>${result.days}</td>
                            <td>
                                <div class="tooltip-container">
                                    ${customAmountHtml}
                                    <div class="tooltip">${tooltipContent}</div>
                                </div>
                            </td>
                            <td class="actual-column" style="display: none;">-</td>
                            <td style="position: relative;">
                                $${result.balance.toFixed(2)}
                                <button class="insert-delete-btn" onclick="deleteCustomEntry('${result.id}')" title="Delete this custom entry">‚àí</button>
                                <button class="insert-add-btn" onclick="showInsertForm(${results.indexOf(result)})" title="Add entry after this row">+</button>
                            </td>
                        </tr>
                    `;
                }
                
                // Always track the balance from each transaction (this will be the final balance after the last transaction)
                finalBalance = result.balance;
            });
            
            html += `
                    <tr class="total-row">
                        <td colspan="3"><strong>Total</strong></td>
                        <td><strong>$${totalInterest.toFixed(2)}</strong></td>
                        <td><strong>$${finalBalance.toFixed(2)}</strong></td>
                    </tr>
                    </tbody>
                </table>
            `;
            
            // Payment changes are tracked but not displayed as a separate summary
            // Modified payments are highlighted in the table instead
            
            document.getElementById(elementId).innerHTML = html;
            document.getElementById('results1').style.display = 'block';
            
            // Auto-indicate that results are ready
            autoSwitchToResults();
        }
        
        function formatDate(date) {
            return date.toLocaleDateString('en-US', {
                month: '2-digit',
                day: '2-digit',
                year: 'numeric'
            });
        }
        
        function getOrdinal(n) {
            // Handle special cases for 11th, 12th, 13th
            if (n >= 11 && n <= 13) {
                return `${n}th`;
            }
            
            // Handle general cases
            const lastDigit = n % 10;
            switch (lastDigit) {
                case 1: return `${n}st`;
                case 2: return `${n}nd`;
                case 3: return `${n}rd`;
                default: return `${n}th`;
            }
        }
        
        // Helper function to add days to a date without month boundary issues
        function addDays(date, days) {
            const result = new Date(date);
            result.setDate(result.getDate() + days);
            return result;
        }
        
        // Helper function to calculate actual days between two dates
        function calculateDaysBetween(startDate, endDate) {
            const timeDiff = endDate.getTime() - startDate.getTime();
            return Math.ceil(timeDiff / (1000 * 60 * 60 * 24));
        }
        
        // Format date for input field (YYYY-MM-DD)
        function formatDateForInput(date) {
            if (typeof date === 'string') {
                // If it's already a formatted date string, try to parse it
                const parsed = new Date(date);
                if (!isNaN(parsed.getTime())) {
                    date = parsed;
                } else {
                    // Try to parse MM/DD/YYYY format
                    const parts = date.split('/');
                    if (parts.length === 3) {
                        date = new Date(parts[2], parts[0] - 1, parts[1]);
                    } else {
                        return '';
                    }
                }
            }
            
            if (!(date instanceof Date) || isNaN(date.getTime())) {
                return '';
            }
            
            return date.toISOString().split('T')[0];
        }
        
        // Validate date format and return parsed date or null
        function validateAndParseDate(dateValue, inputElement) {
            if (!dateValue || !dateValue.trim()) return null;
            
            const trimmedValue = dateValue.trim();
            let parsedDate = null;
            let isValid = false;
            
            // Try MM/DD/YYYY format first
            if (trimmedValue.includes('/')) {
                const parts = trimmedValue.split('/');
                if (parts.length === 3) {
                    const month = parseInt(parts[0], 10);
                    const day = parseInt(parts[1], 10);
                    const year = parseInt(parts[2], 10);
                    
                    if (month >= 1 && month <= 12 && day >= 1 && day <= 31 && year >= 1900 && year <= 2100) {
                        parsedDate = new Date(year, month - 1, day);
                        // Verify the date is actually valid (handles cases like 02/30/2023)
                        if (parsedDate.getFullYear() === year && parsedDate.getMonth() === (month - 1) && parsedDate.getDate() === day) {
                            isValid = true;
                        }
                    }
                }
            }
            
            // Try standard Date parsing as fallback
            if (!isValid) {
                try {
                    parsedDate = new Date(trimmedValue);
                    if (!isNaN(parsedDate.getTime()) && parsedDate.getFullYear() >= 1900 && parsedDate.getFullYear() <= 2100) {
                        isValid = true;
                    }
                } catch (e) {
                    // Parsing failed
                }
            }
            
            // Update input styling based on validation
            if (inputElement) {
                if (isValid) {
                    inputElement.style.border = '';
                    inputElement.style.backgroundColor = '';
                    inputElement.title = '';
                } else {
                    inputElement.style.border = '2px solid #dc3545';
                    inputElement.style.backgroundColor = '#f8d7da';
                    inputElement.title = `Invalid date format: "${trimmedValue}". Please use MM/DD/YYYY format.`;
                }
            }
            
            return isValid ? parsedDate : null;
        }
        
        // Update payment from table edit
        function updatePaymentFromTable(paymentKey, field, newValue) {
            if (!newValue) return;
            
            const originalData = originalPaymentData.get(paymentKey);
            if (!originalData) return;
            
            // Store the modification
            if (!paymentModifications.has(paymentKey)) {
                paymentModifications.set(paymentKey, {});
            }
            
            const modification = paymentModifications.get(paymentKey);
            
            if (field === 'date') {
                // Find the input element for validation styling
                const inputElement = document.querySelector(`input[data-payment-key="${paymentKey}"]`);
                const newDate = validateAndParseDate(newValue, inputElement);
                
                if (newDate) {
                    const originalDate = new Date(originalData.originalDate);
                    
                    if (newDate.getTime() !== originalDate.getTime()) {
                        modification.date = newDate;
                        modification.originalDate = originalData.originalDate;
                    } else {
                        delete modification.date;
                        delete modification.originalDate;
                    }
                    
                    // Update the actual payment data in the payments container
                    updatePaymentInContainer(paymentKey, field, newValue);
                    
                    // Update the payment in the original payments array
                    updatePaymentInTimeline(paymentKey, field, newValue);
                } else {
                    // Invalid date - don't update anything, just show validation error
                    console.warn(`Invalid date format for payment ${paymentKey}: "${newValue}". Payment not updated.`);
                    return;
                }
            }
            
            // If no modifications remain, remove the entry
            if (Object.keys(modification).length === 0) {
                paymentModifications.delete(paymentKey);
            }
            
            // Recalculate results
            calculateGracePeriod();
            
            // Refresh discrepancy analysis if active
            refreshDiscrepancyAnalysis();
        }
        
        // Update payment in the main payments container
        function updatePaymentInContainer(paymentKey, field, newValue) {
            // Extract the payment ID from the key
            const paymentId = paymentKey.replace('payment-', '');
            
            // Find the corresponding payment input in the payments container
            if (field === 'date') {
                const dateInput = document.getElementById(`payment-date-${paymentId}`);
                if (dateInput) {
                    // Convert the date format if needed for the input field
                    if (newValue.includes('/')) {
                        dateInput.value = newValue; // Already in MM/DD/YYYY format
                    } else {
                        // Convert from Date object to MM/DD/YYYY
                        const date = new Date(newValue);
                        if (!isNaN(date.getTime())) {
                            dateInput.value = formatDate(date);
                        }
                    }
                }
            }
        }
        
        // Update payment in the timeline data
        function updatePaymentInTimeline(paymentKey, field, newValue) {
            // The payments are retrieved fresh from getPayments() function each time
            // so we don't need to update a separate timeline array
            // The payment inputs in the DOM are the source of truth
        }
        
        // Generate payment changes summary
        function generatePaymentChangesSummary() {
            if (paymentModifications.size === 0) return '';
            
            let summaryHtml = `
                <div class="payment-changes-summary show">
                    <strong>Payment Modifications:</strong>
                    <ul class="change-list">
            `;
            
            paymentModifications.forEach((changes, paymentKey) => {
                const original = originalPaymentData.get(paymentKey);
                if (!original) return;
                
                const isCustomEntry = paymentKey.startsWith('custom-');
                const entryType = isCustomEntry ? 'Custom Entry' : 'Payment';
                
                if (changes.description !== undefined) {
                    summaryHtml += `
                        <li>‚Ä¢ ${entryType} description changed from "${changes.originalDescription}" to "${changes.description}"</li>
                    `;
                }
                
                if (changes.date !== undefined) {
                    summaryHtml += `
                        <li>‚Ä¢ ${entryType} date changed from ${changes.originalDate} to ${formatDate(changes.date)}</li>
                    `;
                }
                
                if (changes.amount !== undefined) {
                    summaryHtml += `
                        <li>‚Ä¢ ${entryType} amount changed from ${changes.originalAmount >= 0 ? '+' : ''}$${Math.abs(changes.originalAmount).toFixed(2)} to ${changes.amount >= 0 ? '+' : ''}$${Math.abs(changes.amount).toFixed(2)}</li>
                    `;
                }
            });
            
            summaryHtml += `
                    </ul>
                    <div style="margin-top: 8px; font-size: 12px; color: #856404;">
                        <em>Note: Calculations automatically update based on your changes.</em>
                    </div>
                </div>
            `;
            
            return summaryHtml;
        }
        
        // Show insert form at specified row index
        function showInsertForm(afterRowIndex) {
            // Close any existing insert form
            hideInsertForm();
            
            currentInsertRowIndex = afterRowIndex;
            
            // Find the table and the row after which to insert
            const table = document.querySelector('.results-table tbody');
            const rows = table.querySelectorAll('tr');
            const targetRow = rows[afterRowIndex];
            
            if (!targetRow) return;
            
            // Get the date from the target row (2nd column)
            const targetDateCell = targetRow.querySelector('td:nth-child(2)');
            let defaultDate = formatDate(new Date()); // fallback to today
            
            if (targetDateCell) {
                // Check if there's an input field (for payment rows)
                const dateInput = targetDateCell.querySelector('input');
                let targetDateText;
                
                if (dateInput) {
                    targetDateText = dateInput.value.trim();
                } else {
                    targetDateText = targetDateCell.textContent.trim();
                }
                
                // Check if it's a valid date format and not a header
                if (targetDateText && targetDateText !== 'Date' && targetDateText.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
                    defaultDate = targetDateText;
                }
            }
            
            // Create insert form row
            const insertRow = document.createElement('tr');
            insertRow.className = 'insert-form-row';
            insertRow.id = 'insert-form-row';
            
            insertRow.innerHTML = `
                <td>
                    <input type="text" class="insert-form-input" id="insert-description" placeholder="Description">
                </td>
                <td>
                    <input type="text" class="insert-form-input" id="insert-date" value="${defaultDate}" placeholder="MM/DD/YYYY">
                </td>
                <td>
                    -
                </td>
                <td>
                    <input type="number" class="insert-form-input" id="insert-amount" placeholder="0.00" step="0.01">
                </td>
                <td>
                    <div class="insert-form-buttons">
                        <button class="insert-btn insert-btn-save" onclick="saveCustomEntry()">Save</button>
                        <button class="insert-btn insert-btn-cancel" onclick="hideInsertForm()">Cancel</button>
                    </div>
                </td>
            `;
            
            // Insert the form row after the target row
            targetRow.parentNode.insertBefore(insertRow, targetRow.nextSibling);
            
            // Focus on the description input
            document.getElementById('insert-description').focus();
        }
        
        // Hide insert form
        function hideInsertForm() {
            const insertRow = document.getElementById('insert-form-row');
            if (insertRow) {
                insertRow.remove();
            }
            currentInsertRowIndex = -1;
        }
        
        // Save custom entry
        function saveCustomEntry() {
            const description = document.getElementById('insert-description').value.trim();
            const dateValue = document.getElementById('insert-date').value;
            const amount = parseFloat(document.getElementById('insert-amount').value);
            
            if (!description || !dateValue || isNaN(amount) || amount === 0) {
                alert('Please enter a description, valid date, and non-zero amount.');
                return;
            }
            
            // Parse MM/DD/YYYY date format
            let entryDate;
            if (dateValue.includes('/')) {
                const parts = dateValue.split('/');
                if (parts.length === 3) {
                    const month = parseInt(parts[0], 10);
                    const day = parseInt(parts[1], 10);
                    const year = parseInt(parts[2], 10);
                    entryDate = new Date(year, month - 1, day);
                } else {
                    alert('Please enter date in MM/DD/YYYY format.');
                    return;
                }
            } else {
                entryDate = new Date(dateValue + 'T00:00:00');
            }
            
            if (isNaN(entryDate.getTime())) {
                alert('Please enter a valid date in MM/DD/YYYY format.');
                return;
            }
            
            // Create custom entry object
            const customEntry = {
                id: Date.now() + Math.random(), // Unique ID
                type: 'custom',
                subType: 'custom',
                date: entryDate,
                amount: amount,
                description: description,
                insertAfterIndex: currentInsertRowIndex
            };
            
            // Add to custom entries
            customEntries.push(customEntry);
            
            // Hide form and recalculate
            hideInsertForm();
            calculateGracePeriod();
            
            // Refresh discrepancy analysis if active
            refreshDiscrepancyAnalysis();
        }
        
        // Update custom entry from table edit
        function updateCustomEntryFromTable(customKey, field, newValue) {
            if (!newValue && field !== 'amount') return;
            
            // For custom entries, directly update the data without modification tracking
            updateCustomEntryData(customKey, field, newValue);
            
            // Recalculate results
            calculateGracePeriod();
            
            // Refresh discrepancy analysis if active
            refreshDiscrepancyAnalysis();
        }
        
        // Update custom entry data in the customEntries array
        function updateCustomEntryData(customKey, field, newValue) {
            const entryId = customKey.replace('custom-', '');
            const customEntry = customEntries.find(entry => entry.id == entryId);
            
            if (customEntry) {
                if (field === 'description') {
                    customEntry.description = newValue;
                } else if (field === 'date') {
                    // Parse MM/DD/YYYY format
                    if (newValue.includes('/')) {
                        const parts = newValue.split('/');
                        if (parts.length === 3) {
                            const month = parseInt(parts[0], 10);
                            const day = parseInt(parts[1], 10);
                            const year = parseInt(parts[2], 10);
                            customEntry.date = new Date(year, month - 1, day);
                        }
                    } else {
                        customEntry.date = new Date(newValue + 'T00:00:00');
                    }
                } else if (field === 'amount') {
                    customEntry.amount = parseFloat(newValue);
                }
            }
        }
        
        // Delete custom entry
        function deleteCustomEntry(entryId) {
            if (confirm('Are you sure you want to delete this custom entry?')) {
                // Remove from custom entries array
                customEntries = customEntries.filter(entry => entry.id != entryId);
                
                // Remove any modifications for this entry
                const customKey = `custom-${entryId}`;
                paymentModifications.delete(customKey);
                originalPaymentData.delete(customKey);
                
                // Recalculate results
                calculateGracePeriod();
                
                // Refresh discrepancy analysis if active
                refreshDiscrepancyAnalysis();
            }
        }
        
        // Export results table to CSV
        function exportResultsToCSV() {
            // Check if actual column is visible (CSV comparison is active) - declare early
            const actualHeader = document.getElementById('actualColumn');
            const hasActualColumn = actualHeader && actualHeader.style.display !== 'none';
            
            // Get the current calculation parameters
            const rate = parseFloat(document.getElementById('rate1').value);
            const issueDate = document.getElementById('issueDate1').value;
            const dueDate = document.getElementById('dueDate1').value;
            const interval = parseInt(document.getElementById('interval1').value);
            const principal = parseFloat(document.getElementById('principal1').value);
            const periods = parseInt(document.getElementById('periods1').value);
            const interestType = document.querySelector('input[name="interestType"]:checked').value;
            
            // Check if results are available
            const resultsElement = document.getElementById('results1');
            if (!resultsElement || resultsElement.style.display === 'none') {
                showToast('No results to export. Please run calculations first.', 'warning');
                return;
            }
            
            // Get the results data
            const payments = getPayments();
            
            // Recreate the calculation to get the results data
            let csvContent = '';
            
            // Add header information
            csvContent += 'Interest Calculation Export\n';
            csvContent += `Generated on: ${new Date().toLocaleString()}\n\n`;
            
            // Add calculation parameters
            csvContent += 'Calculation Parameters:\n';
            csvContent += `Annual Interest Rate,%${rate}%\n`;
            csvContent += `Issue Date,${issueDate}\n`;
            csvContent += `Due Date,${dueDate}\n`;
            csvContent += `Interest Interval,${interval} days\n`;
            csvContent += `Starting Principal,$${principal.toFixed(2)}\n`;
            csvContent += `Interest Type,${interestType.charAt(0).toUpperCase() + interestType.slice(1)} Interest\n`;
            csvContent += `Number of Periods Displayed,${periods}\n`;
            
            // Add CSV comparison info if active
            if (hasActualColumn && currentDiscrepancyData) {
                csvContent += `CSV Comparison Active,Yes\n`;
                csvContent += `CSV Data Points,${currentDiscrepancyData.length}\n`;
                csvContent += `Export includes actual vs calculated comparison\n`;
            }
            
            csvContent += '\n';
            
            // Add payment summary if any
            if (payments.length > 0) {
                csvContent += 'Payments Applied:\n';
                payments.forEach((payment, index) => {
                    csvContent += `Payment ${index + 1},$${payment.amount.toFixed(2)},${formatDate(payment.date)}\n`;
                });
                csvContent += '\n';
            }
            
            // Add custom entries summary if any
            if (customEntries.length > 0) {
                csvContent += 'Custom Entries:\n';
                customEntries.forEach((entry, index) => {
                    const sign = entry.amount >= 0 ? '+' : '';
                    csvContent += `${entry.description},${sign}$${entry.amount.toFixed(2)},${formatDate(entry.date)}\n`;
                });
                csvContent += '\n';
            }
            
            // Add modifications summary if any
            if (paymentModifications.size > 0) {
                csvContent += 'Modifications Made:\n';
                paymentModifications.forEach((changes, paymentKey) => {
                    const original = originalPaymentData.get(paymentKey);
                    const isCustomEntry = paymentKey.startsWith('custom-');
                    const entryType = isCustomEntry ? 'Custom Entry' : 'Payment';
                    
                    if (changes.description !== undefined) {
                        csvContent += `${entryType} description changed from "${changes.originalDescription}" to "${changes.description}"\n`;
                    }
                    if (changes.date !== undefined) {
                        csvContent += `${entryType} date changed from ${changes.originalDate} to ${formatDate(changes.date)}\n`;
                    }
                    if (changes.amount !== undefined) {
                        csvContent += `${entryType} amount changed from $${changes.originalAmount.toFixed(2)} to $${changes.amount.toFixed(2)}\n`;
                    }
                });
                csvContent += '\n';
            }
            
            // Add the main results table
            csvContent += 'Interest Calculation Results:\n';
            
            if (hasActualColumn) {
                csvContent += 'Period,Date,Days,Interest/Amount,Actual,Running Balance,Type,Notes,Comparison\n';
            } else {
                csvContent += 'Period,Date,Days,Interest/Amount,Running Balance,Type,Notes\n';
            }
            
            // Get the table data from the DOM
            const table = document.querySelector('.results-table tbody');
            if (table) {
                const rows = table.querySelectorAll('tr:not(.insert-form-row)');
                
                rows.forEach(row => {
                    const cells = row.querySelectorAll('td');
                    const minCells = hasActualColumn ? 6 : 5;
                    
                    if (cells.length >= minCells) {
                        const period = cells[0].textContent.replace(/MODIFIED|CUSTOM/g, '').trim();
                        const date = cells[1].querySelector('input') ? cells[1].querySelector('input').value : cells[1].textContent.trim();
                        const days = cells[2].textContent.trim();
                        const amount = cells[3].textContent.replace(/[\$\+\-]/g, '').trim();
                        
                        let actual = '';
                        let balance, balanceIndex;
                        
                        if (hasActualColumn) {
                            // Actual column is at index 4, balance is at index 5
                            const actualCell = cells[4];
                            const actualSpan = actualCell.querySelector('.actual-amount');
                            actual = actualSpan ? actualSpan.textContent.replace('$', '').trim() : '-';
                            balanceIndex = 5;
                        } else {
                            // No actual column, balance is at index 4
                            balanceIndex = 4;
                        }
                        
                        balance = cells[balanceIndex].textContent.replace('$', '').trim();
                        
                        // Determine type and notes
                        let type = 'Interest';
                        let notes = '';
                        
                        if (row.classList.contains('custom-entry-row')) {
                            type = 'Custom Entry';
                        } else if (row.style.backgroundColor.includes('rgb(232, 245, 232)') || row.style.backgroundColor.includes('#e8f5e8')) {
                            type = 'Payment';
                        } else if (row.classList.contains('payment-row-modified')) {
                            type = 'Payment (Modified)';
                        } else if (row.classList.contains('total-row')) {
                            type = 'Total';
                        }
                        
                        if (row.querySelector('.change-indicator')) {
                            notes += 'Modified';
                        }
                        
                        // Get comparison indicator if present
                        let comparison = '';
                        if (hasActualColumn) {
                            const actualCell = cells[4];
                            const indicator = actualCell.querySelector('.comparison-indicator');
                            if (indicator && indicator.textContent.trim()) {
                                const indicatorText = indicator.textContent.trim();
                                if (indicatorText.includes('‚úÖ')) {
                                    comparison = 'Match';
                                } else if (indicatorText.includes('‚¨ÜÔ∏è')) {
                                    comparison = 'Higher than calculated';
                                } else if (indicatorText.includes('‚¨áÔ∏è')) {
                                    comparison = 'Lower than calculated';
                                }
                            }
                        }
                        
                        if (hasActualColumn) {
                            csvContent += `"${period}","${date}","${days}","$${amount}","$${actual}","$${balance}","${type}","${notes}","${comparison}"\n`;
                        } else {
                            csvContent += `"${period}","${date}","${days}","$${amount}","$${balance}","${type}","${notes}"\n`;
                        }
                    }
                });
            }
            
            // Create and download the CSV file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                
                // Generate filename with timestamp
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                link.setAttribute('download', `interest_calculation_${timestamp}.csv`);
                
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Show success toast
                setTimeout(() => {
                    showToast('CSV file downloaded successfully!', 'success');
                }, 100);
            } else {
                showToast('CSV export is not supported in this browser.', 'error');
            }
        }
        
        // Show toast notification
        function showToast(message, type = 'success', duration = 3000) {
            // Remove any existing toasts
            const existingToasts = document.querySelectorAll('.toast');
            existingToasts.forEach(toast => toast.remove());
            
            // Create toast element
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            // Set icon based on type
            let icon = '‚úÖ';
            if (type === 'error') icon = '‚ùå';
            if (type === 'warning') icon = '‚ö†Ô∏è';
            if (type === 'info') icon = '‚ÑπÔ∏è';
            
            toast.innerHTML = `
                <span class="toast-icon">${icon}</span>
                <span class="toast-message">${message}</span>
            `;
            
            // Add to page
            document.body.appendChild(toast);
            
            // Show toast
            setTimeout(() => {
                toast.classList.add('show');
            }, 10);
            
            // Hide and remove toast after duration
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, duration);
        }

        // Get description for entry type
        function getEntryDescription(type, amount) {
            const isPositive = amount > 0;
            const absAmount = Math.abs(amount);
            
            switch (type) {
                case 'payment':
                    return isPositive ? `Payment Reversal` : `Payment`;
                case 'interest':
                    return isPositive ? `Interest Adjustment` : `Interest Credit`;
                case 'fee':
                    return isPositive ? `Fee/Charge` : `Fee Reversal`;
                case 'credit':
                    return isPositive ? `Credit Reversal` : `Credit Note`;
                default:
                    return isPositive ? `Custom Charge` : `Custom Credit`;
            }
        }
        
        // Add event listeners for automatic calculation
        function setupEventListeners() {
            // Input fields that should trigger recalculation
            const inputIds = ['rate1', 'issueDate1', 'dueDate1', 'interval1', 'principal1', 'periods1'];
            
            inputIds.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', calculateGracePeriod);
                    element.addEventListener('change', calculateGracePeriod);
                }
            });
            
            // Interest type radio buttons
            const radioButtons = document.querySelectorAll('input[name="interestType"]');
            radioButtons.forEach(radio => {
                radio.addEventListener('change', calculateGracePeriod);
            });
        }
        
        // Add event listeners to dynamically added payment rows
        function addPaymentEventListeners(paymentId) {
            const amountInput = document.getElementById(`payment-amount-${paymentId}`);
            const dateInput = document.getElementById(`payment-date-${paymentId}`);
            
            if (amountInput) {
                amountInput.addEventListener('input', calculateGracePeriod);
                amountInput.addEventListener('change', calculateGracePeriod);
            }
            
            if (dateInput) {
                dateInput.addEventListener('input', calculateGracePeriod);
                dateInput.addEventListener('change', calculateGracePeriod);
            }
        }
        
        // Discrepancy checker functionality
        let discrepancyData = null;
        let calculatedResults = null;
        
        function initializeDiscrepancyDragAndDrop() {
            const uploadZone = document.getElementById('discrepancyUploadZone');
            const fileInput = document.getElementById('discrepancyCsvFileInput');
            
            if (!uploadZone || !fileInput) return;
            
            // Drag and drop events
            uploadZone.addEventListener('dragover', function(e) {
                e.preventDefault();
                uploadZone.style.backgroundColor = '#e8f4fd';
                uploadZone.style.borderColor = '#007bff';
            });
            
            uploadZone.addEventListener('dragleave', function(e) {
                e.preventDefault();
                uploadZone.style.backgroundColor = '';
                uploadZone.style.borderColor = '';
            });
            
            uploadZone.addEventListener('drop', function(e) {
                e.preventDefault();
                uploadZone.style.backgroundColor = '';
                uploadZone.style.borderColor = '';
                
                const files = e.dataTransfer.files;
                if (files.length > 0 && files[0].type === 'text/csv') {
                    handleDiscrepancyFile(files[0]);
                }
            });
            
            // Click to upload
            uploadZone.addEventListener('click', function() {
                fileInput.click();
            });
            
            fileInput.addEventListener('change', function(e) {
                if (e.target.files.length > 0) {
                    handleDiscrepancyFile(e.target.files[0]);
                }
            });
        }
        
        function handleDiscrepancyFile(file) {
            const fileInfo = document.getElementById('discrepancyFileInfo');
            const fileName = document.getElementById('discrepancyFileName');
            const fileSize = document.getElementById('discrepancyFileSize');
            const parseSection = document.getElementById('discrepancyParseSection');
            
            fileName.textContent = file.name;
            fileSize.textContent = (file.size / 1024).toFixed(2) + ' KB';
            fileInfo.style.display = 'block';
            parseSection.style.display = 'block';
            
            // Store the file for parsing
            window.discrepancyFile = file;
        }
        
        function parseDiscrepancyCSV() {
            if (!window.discrepancyFile) {
                showDiscrepancyStatus('No file selected', 'error');
                return;
            }
            
            // Check if we have calculated results
            const resultsContent = document.getElementById('results1-content');
            if (!resultsContent || !resultsContent.innerHTML.trim()) {
                showDiscrepancyStatus('Please calculate interest charges first using the Calculator tab', 'error');
                return;
            }
            
            showDiscrepancyStatus('Parsing CSV file...', 'info');
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csvText = e.target.result;
                    const parsedData = parseDiscrepancyCSVData(csvText);
                    
                    if (parsedData && parsedData.length > 0) {
                        discrepancyData = parsedData;
                        showDiscrepancyPreview(parsedData);
                        analyzeDiscrepancies();
                    } else {
                        showDiscrepancyStatus('No interest charges found in CSV file', 'warning');
                    }
                } catch (error) {
                    showDiscrepancyStatus('Error parsing CSV file: ' + error.message, 'error');
                }
            };
            
            reader.readAsText(window.discrepancyFile);
        }
        
        function parseDiscrepancyCSVData(csvText) {
            const lines = csvText.split('\n');
            const interestCharges = [];
            
            // Look for different CSV formats
            let headerIndex = -1;
            let isSimpleFormat = false;
            let isBillInspectorFormat = false;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line.includes('Bill ID') && line.includes('Date') && line.includes('Total')) {
                    // Simple bill export format (like 236548126.csv)
                    headerIndex = i;
                    isSimpleFormat = true;
                    break;
                } else if (line.includes('Interest line items')) {
                    // Bill Inspector format - has Interest line items section
                    isBillInspectorFormat = true;
                    break;
                }
            }
            
            if (isSimpleFormat) {
                // Parse simple format (existing logic)
                const headers = lines[headerIndex].split(',').map(h => h.replace(/"/g, '').trim());
                const dateIndex = headers.indexOf('Date');
                const totalIndex = headers.indexOf('Total');
                const activityIndex = headers.indexOf('Activity');
                const descriptionIndex = headers.indexOf('Description');
                
                for (let i = headerIndex + 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    const values = parseCSVLine(line);
                    if (values.length <= Math.max(dateIndex, totalIndex, activityIndex, descriptionIndex)) continue;
                    
                    const activity = values[activityIndex] ? values[activityIndex].replace(/"/g, '').trim() : '';
                    const description = values[descriptionIndex] ? values[descriptionIndex].replace(/"/g, '').trim() : '';
                    
                    // Look for interest charges
                    if (activity === 'Interest' || description.toLowerCase().includes('interest')) {
                        const date = values[dateIndex] ? values[dateIndex].replace(/"/g, '').trim() : '';
                        const total = values[totalIndex] ? parseFloat(values[totalIndex].replace(/"/g, '').replace(/[,$]/g, '')) : 0;
                        
                        if (date && !isNaN(total) && total > 0) {
                            interestCharges.push({
                                date: date,
                                amount: total,
                                description: description || 'Interest charge'
                            });
                        }
                    }
                }
            } else if (isBillInspectorFormat) {
                // Parse Bill Inspector format
                const interestLineItemsStart = findSectionStart(lines, 'Interest line items');
                if (interestLineItemsStart > 0 && interestLineItemsStart + 1 < lines.length) {
                    // Get the header line for Interest line items
                    const headerLine = lines[interestLineItemsStart + 1];
                    const headers = headerLine.split(',');
                    
                    // Find relevant column indices
                    const dateIndex = headers.findIndex(h => h.trim() === 'date');
                    const priceIndex = headers.findIndex(h => h.trim() === 'price');
                    const createdAtIndex = headers.findIndex(h => h.trim() === 'created_at');
                    
                    // Parse interest line items
                    for (let i = interestLineItemsStart + 2; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) break; // End of section
                        
                        const values = parseCSVLine(line);
                        if (values.length > Math.max(dateIndex, priceIndex, createdAtIndex)) {
                            const date = values[dateIndex] ? values[dateIndex].trim() : '';
                            const amount = values[priceIndex] ? parseFloat(values[priceIndex]) : 0;
                            
                            if (date && !isNaN(amount) && amount > 0) {
                                // Convert date format from YYYY-MM-DD to MM/DD/YYYY if needed
                                let formattedDate = date;
                                if (date.includes('-') && date.length === 10) {
                                    const [year, month, day] = date.split('-');
                                    formattedDate = `${month.padStart(2, '0')}/${day.padStart(2, '0')}/${year}`;
                                }
                                
                                interestCharges.push({
                                    date: formattedDate,
                                    amount: amount,
                                    description: 'Interest charge from Bill Inspector'
                                });
                            }
                        }
                    }
                }
            } else {
                throw new Error('Could not find expected CSV header format. Supported formats: Simple Bill Export or Bill Inspector CSV');
            }
            
            return interestCharges;
        }
        
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            
            result.push(current);
            return result;
        }
        
        function showDiscrepancyStatus(message, type) {
            const status = document.getElementById('discrepancyStatus');
            status.style.display = 'block';
            status.textContent = message;
            
            // Reset classes
            status.className = '';
            
            if (type === 'error') {
                status.style.backgroundColor = '#f8d7da';
                status.style.color = '#721c24';
                status.style.borderLeft = '4px solid #dc3545';
            } else if (type === 'success') {
                status.style.backgroundColor = '#d4edda';
                status.style.color = '#155724';
                status.style.borderLeft = '4px solid #28a745';
            } else if (type === 'warning') {
                status.style.backgroundColor = '#fff3cd';
                status.style.color = '#856404';
                status.style.borderLeft = '4px solid #ffc107';
            } else {
                status.style.backgroundColor = '#d1ecf1';
                status.style.color = '#0c5460';
                status.style.borderLeft = '4px solid #17a2b8';
            }
        }
        
        function showDiscrepancyPreview(data) {
            const preview = document.getElementById('discrepancyPreview');
            preview.style.display = 'block';
            
            let html = `<h4>Found ${data.length} interest charge(s) in CSV:</h4><ul>`;
            data.forEach(charge => {
                html += `<li><strong>${charge.date}:</strong> $${charge.amount.toFixed(2)} - ${charge.description}</li>`;
            });
            html += '</ul>';
            
            preview.innerHTML = html;
            showDiscrepancyStatus(`Successfully parsed ${data.length} interest charges from CSV`, 'success');
        }
        
        function analyzeDiscrepancies() {
            if (!discrepancyData) return;
            
            // Get calculated results from the results table
            const calculatedCharges = getCalculatedInterestCharges();
            
            if (!calculatedCharges || calculatedCharges.length === 0) {
                showDiscrepancyStatus('No calculated interest charges found. Please run calculations first.', 'error');
                return;
            }
            
            // Compare actual vs calculated
            const comparison = compareInterestCharges(discrepancyData, calculatedCharges);
            displayDiscrepancyResults(comparison);
        }
        
        function getCalculatedInterestCharges() {
            const results = [];
            const table = document.querySelector('#results1-content .results-table tbody');
            
            if (!table) return results;
            
            const rows = table.querySelectorAll('tr:not(.insert-form-row)');
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                if (cells.length >= 4) {
                    const dateCell = cells[1];
                    const interestCell = cells[3]; // Fixed: Interest is in column 3, not 4
                    
                    if (dateCell && interestCell) {
                        const date = dateCell.textContent.trim();
                        const interestText = interestCell.textContent.trim();
                        
                        // Handle both simple $XX.XX format and tooltip container format
                        let interestMatch = interestText.match(/\$([0-9,]+\.?[0-9]*)/);
                        
                        if (interestMatch && date !== 'Date') {
                            const amount = parseFloat(interestMatch[1].replace(/,/g, ''));
                            if (!isNaN(amount) && amount > 0) {
                                results.push({
                                    date: date,
                                    amount: amount,
                                    type: 'calculated'
                                });
                            }
                        }
                    }
                }
            });
            
            return results;
        }
        
        function compareInterestCharges(actualCharges, calculatedCharges) {
            const comparison = {
                matches: [],
                discrepancies: [],
                missing: [],
                extra: []
            };
            
            // Create maps for easier comparison
            const actualMap = new Map();
            actualCharges.forEach(charge => {
                const key = charge.date;
                actualMap.set(key, charge);
            });
            
            const calculatedMap = new Map();
            calculatedCharges.forEach(charge => {
                const key = charge.date;
                calculatedMap.set(key, charge);
            });
            
            // Compare calculated vs actual
            calculatedCharges.forEach(calc => {
                const actual = actualMap.get(calc.date);
                if (actual) {
                    const difference = Math.abs(actual.amount - calc.amount);
                    if (difference < 0.01) {
                        comparison.matches.push({
                            date: calc.date,
                            calculated: calc.amount,
                            actual: actual.amount,
                            difference: 0
                        });
                    } else {
                        comparison.discrepancies.push({
                            date: calc.date,
                            calculated: calc.amount,
                            actual: actual.amount,
                            difference: actual.amount - calc.amount
                        });
                    }
                } else {
                    comparison.missing.push(calc);
                }
            });
            
            // Find extra charges in actual that aren't in calculated
            actualCharges.forEach(actual => {
                if (!calculatedMap.has(actual.date)) {
                    comparison.extra.push(actual);
                }
            });
            
            return comparison;
        }
        
        function displayDiscrepancyResults(comparison) {
            const resultsDiv = document.getElementById('discrepancyResults');
            const summaryDiv = document.getElementById('discrepancySummary');
            const tableDiv = document.getElementById('discrepancyTable');
            
            resultsDiv.style.display = 'block';
            
            // Create summary
            const totalDiscrepancies = comparison.discrepancies.length + comparison.missing.length + comparison.extra.length;
            let summaryHtml = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <div style="text-align: center; padding: 10px; background: #d4edda; border-radius: 4px;">
                        <div style="font-size: 24px; font-weight: bold; color: #155724;">${comparison.matches.length}</div>
                        <div style="color: #155724;">Matches</div>
                    </div>
                    <div style="text-align: center; padding: 10px; background: #f8d7da; border-radius: 4px;">
                        <div style="font-size: 24px; font-weight: bold; color: #721c24;">${comparison.discrepancies.length}</div>
                        <div style="color: #721c24;">Discrepancies</div>
                    </div>
                    <div style="text-align: center; padding: 10px; background: #fff3cd; border-radius: 4px;">
                        <div style="font-size: 24px; font-weight: bold; color: #856404;">${comparison.missing.length}</div>
                        <div style="color: #856404;">Missing Charges</div>
                    </div>
                    <div style="text-align: center; padding: 10px; background: #d1ecf1; border-radius: 4px;">
                        <div style="font-size: 24px; font-weight: bold; color: #0c5460;">${comparison.extra.length}</div>
                        <div style="color: #0c5460;">Extra Charges</div>
                    </div>
                </div>
            `;
            
            summaryDiv.innerHTML = summaryHtml;
            
            // Create detailed table
            let tableHtml = `
                <table class="results-table" style="width: 100%; margin-top: 15px;">
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Calculated</th>
                            <th>Actual</th>
                            <th>Difference</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            // Add matches
            comparison.matches.forEach(match => {
                tableHtml += `
                    <tr style="background-color: #d4edda;">
                        <td>${match.date}</td>
                        <td>$${match.calculated.toFixed(2)}</td>
                        <td>$${match.actual.toFixed(2)}</td>
                        <td>$0.00</td>
                        <td style="color: #155724; font-weight: bold;">‚úì Match</td>
                    </tr>
                `;
            });
            
            // Add discrepancies
            comparison.discrepancies.forEach(disc => {
                const diffColor = disc.difference > 0 ? '#721c24' : '#0c5460';
                const diffSymbol = disc.difference > 0 ? '+' : '';
                tableHtml += `
                    <tr style="background-color: #f8d7da;">
                        <td>${disc.date}</td>
                        <td>$${disc.calculated.toFixed(2)}</td>
                        <td>$${disc.actual.toFixed(2)}</td>
                        <td style="color: ${diffColor}; font-weight: bold;">${diffSymbol}$${disc.difference.toFixed(2)}</td>
                        <td style="color: #721c24; font-weight: bold;">‚ö† Discrepancy</td>
                    </tr>
                `;
            });
            
            // Add missing charges
            comparison.missing.forEach(missing => {
                tableHtml += `
                    <tr style="background-color: #fff3cd;">
                        <td>${missing.date}</td>
                        <td>$${missing.amount.toFixed(2)}</td>
                        <td>-</td>
                        <td style="color: #856404; font-weight: bold;">-$${missing.amount.toFixed(2)}</td>
                        <td style="color: #856404; font-weight: bold;">‚ö† Missing</td>
                    </tr>
                `;
            });
            
            // Add extra charges
            comparison.extra.forEach(extra => {
                tableHtml += `
                    <tr style="background-color: #d1ecf1;">
                        <td>${extra.date}</td>
                        <td>-</td>
                        <td>$${extra.amount.toFixed(2)}</td>
                        <td style="color: #0c5460; font-weight: bold;">+$${extra.amount.toFixed(2)}</td>
                        <td style="color: #0c5460; font-weight: bold;">‚Ñπ Extra</td>
                    </tr>
                `;
            });
            
            tableHtml += '</tbody></table>';
            tableDiv.innerHTML = tableHtml;
            
            // Show final status
            if (totalDiscrepancies === 0) {
                showDiscrepancyStatus('‚úÖ All interest charges match perfectly!', 'success');
            } else {
                showDiscrepancyStatus(`‚ö† Found ${totalDiscrepancies} discrepancies that need attention`, 'warning');
            }
        }

        // Initialize with calculations on page load
        window.onload = function() {
            setupEventListeners();
            initializeDragAndDrop();
            initializeDiscrepancyDragAndDrop();
            setupResultsDiscrepancyUpload();
            calculateGracePeriod();
        };
        
        // Handle Compare Bill CSV button click with validation
        function handleCompareButtonClick() {
            if (!hasUsedUpToToday) {
                showDiscrepancyStatus('‚ö†Ô∏è Please click "Up to Today" button first to ensure all interest charges are calculated for accurate comparison.', 'warning');
                return;
            }
            
            // If validation passes, trigger the file input
            document.getElementById('resultsDiscrepancyCsvInput').click();
        }
        
        // Setup integrated discrepancy checking in results tab
        function setupResultsDiscrepancyUpload() {
            const fileInput = document.getElementById('resultsDiscrepancyCsvInput');
            if (fileInput) {
                fileInput.addEventListener('change', function(e) {
                    if (e.target.files.length > 0) {
                        // Validate that "Up to Today" has been used
                        if (!hasUsedUpToToday) {
                            showDiscrepancyStatus('‚ö†Ô∏è Please click "Up to Today" button first to ensure all interest charges are calculated for accurate comparison.', 'warning');
                            // Clear the file input to prevent processing
                            e.target.value = '';
                            return;
                        }
                        
                        processResultsDiscrepancyFile(e.target.files[0]);
                    }
                });
            }
        }
        
        function processResultsDiscrepancyFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csvText = e.target.result;
                    const parsedData = parseDiscrepancyCSVData(csvText);
                    
                    if (parsedData && parsedData.length > 0) {
                        // Store the discrepancy data for future refreshes
                        currentDiscrepancyData = parsedData;
                        integrateDiscrepancyData(parsedData);
                        showDiscrepancyStatus(`‚úÖ Successfully loaded ${parsedData.length} interest charges from CSV`, 'success');
                    } else {
                        showDiscrepancyStatus('‚ö†Ô∏è No interest charges found in CSV file', 'warning');
                    }
                } catch (error) {
                    showDiscrepancyStatus('‚ùå Error parsing CSV file: ' + error.message, 'error');
                }
            };
            
            reader.readAsText(file);
        }
        
        function integrateDiscrepancyData(actualCharges) {
            // Show the actual column in the results table
            showActualColumn();
            
            // Get calculated charges from the current results
            const calculatedCharges = getCalculatedInterestCharges();
            
            if (calculatedCharges.length === 0) {
                showDiscrepancyStatus('‚ö†Ô∏è No calculated interest charges found. Please run calculations first.', 'warning');
                return;
            }
            
            // Compare and update the table
            const comparison = compareInterestCharges(actualCharges, calculatedCharges);
            updateResultsTableWithActual(actualCharges, comparison);
            showDiscrepancySummary(comparison);
        }
        
        function showActualColumn() {
            // Show the actual column header
            const actualHeader = document.getElementById('actualColumn');
            if (actualHeader) {
                actualHeader.style.display = 'table-cell';
            }
            
            // Show all actual column cells
            const actualCells = document.querySelectorAll('.actual-column');
            actualCells.forEach(cell => {
                cell.style.display = 'table-cell';
            });
            
            // Disable the periods input to prevent breaking the comparison
            const periodsInput = document.getElementById('periods1');
            if (periodsInput) {
                periodsInput.disabled = true;
                periodsInput.style.backgroundColor = '#e9ecef';
                periodsInput.style.color = '#6c757d';
                periodsInput.title = 'Disabled during CSV comparison to maintain data integrity';
            }
            
            // Disable the "Up to Today" button to prevent changing the calculation
            const upToTodayBtn = document.getElementById('upToTodayBtn');
            if (upToTodayBtn) {
                upToTodayBtn.disabled = true;
                upToTodayBtn.style.backgroundColor = '#6c757d';
                upToTodayBtn.style.cursor = 'not-allowed';
                upToTodayBtn.title = 'Disabled during CSV comparison to maintain data integrity';
            }
            
            // Show the Clear Comparison button
            const clearBtn = document.getElementById('clearComparisonBtn');
            if (clearBtn) {
                clearBtn.style.display = 'flex';
            }
        }
        
        function updateResultsTableWithActual(actualCharges, comparison) {
            // Create a map of actual charges by date
            const actualMap = new Map();
            actualCharges.forEach(charge => {
                actualMap.set(charge.date, charge.amount);
            });
            
            // Update each row with actual data and comparison indicators
            const rows = document.querySelectorAll('.results-table tbody tr');
            rows.forEach(row => {
                const actualCell = row.querySelector('.actual-column');
                if (!actualCell) return;
                
                const dateCell = row.querySelector('td:nth-child(2)');
                if (!dateCell) return;
                
                const date = dateCell.textContent.trim();
                const actualAmount = actualMap.get(date);
                
                if (actualAmount !== undefined) {
                    const actualSpan = actualCell.querySelector('.actual-amount');
                    const indicatorSpan = actualCell.querySelector('.comparison-indicator');
                    
                    if (actualSpan) {
                        actualSpan.textContent = `$${actualAmount.toFixed(2)}`;
                    }
                    
                    // Find the comparison result for this date
                    let comparisonResult = null;
                    if (comparison.matches.find(m => m.date === date)) {
                        comparisonResult = { type: 'match', symbol: '‚úÖ', color: '#155724' };
                    } else if (comparison.discrepancies.find(d => d.date === date)) {
                        const disc = comparison.discrepancies.find(d => d.date === date);
                        comparisonResult = { 
                            type: 'discrepancy', 
                            symbol: disc.difference > 0 ? '‚¨ÜÔ∏è' : '‚¨áÔ∏è', 
                            color: disc.difference > 0 ? '#721c24' : '#0c5460',
                            title: `Difference: ${disc.difference > 0 ? '+' : ''}$${disc.difference.toFixed(2)}`
                        };
                    }
                    
                    if (comparisonResult && indicatorSpan) {
                        indicatorSpan.innerHTML = `<span style="color: ${comparisonResult.color};" title="${comparisonResult.title || comparisonResult.type}">${comparisonResult.symbol}</span>`;
                    }
                    
                    // Highlight the row based on comparison
                    if (comparisonResult) {
                        if (comparisonResult.type === 'match') {
                            row.style.backgroundColor = row.style.backgroundColor || '#d4edda';
                            row.style.borderLeft = '3px solid #28a745';
                        } else if (comparisonResult.type === 'discrepancy') {
                            row.style.backgroundColor = row.style.backgroundColor || '#f8d7da';
                            row.style.borderLeft = '3px solid #dc3545';
                        }
                    }
                }
            });
        }
        
        function showDiscrepancySummary(comparison) {
            // Summary is now integrated into the main table with visual indicators
            // No need for status banner - information is visible in the table
        }
        
        function clearDiscrepancyAnalysis() {
            // Hide the actual column
            const actualHeader = document.getElementById('actualColumn');
            if (actualHeader) {
                actualHeader.style.display = 'none';
            }
            
            const actualCells = document.querySelectorAll('.actual-column');
            actualCells.forEach(cell => {
                cell.style.display = 'none';
            });
            
            // Re-enable the periods input
            const periodsInput = document.getElementById('periods1');
            if (periodsInput) {
                periodsInput.disabled = false;
                periodsInput.style.backgroundColor = '';
                periodsInput.style.color = '';
                periodsInput.title = '';
            }
            
            // Re-enable the "Up to Today" button
            const upToTodayBtn = document.getElementById('upToTodayBtn');
            if (upToTodayBtn) {
                upToTodayBtn.disabled = false;
                upToTodayBtn.style.backgroundColor = '#17a2b8';
                upToTodayBtn.style.cursor = 'pointer';
                upToTodayBtn.title = '';
            }
            
            // Hide the Clear Comparison button
            const clearBtn = document.getElementById('clearComparisonBtn');
            if (clearBtn) {
                clearBtn.style.display = 'none';
            }
            
            // Clear row highlighting
            const rows = document.querySelectorAll('.results-table tbody tr');
            rows.forEach(row => {
                row.style.borderLeft = '';
                // Only reset background if it was set by discrepancy analysis
                if (row.style.backgroundColor === 'rgb(212, 237, 218)' || row.style.backgroundColor === 'rgb(248, 215, 218)') {
                    row.style.backgroundColor = '';
                }
            });
            
            // Clear the file input and stored data
            const fileInput = document.getElementById('resultsDiscrepancyCsvInput');
            if (fileInput) {
                fileInput.value = '';
            }
            
            // Clear stored discrepancy data
            currentDiscrepancyData = null;
        }
    </script>
</body>
</html>
</html>
